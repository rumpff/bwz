<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>msk_player</maskName>
  <events>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign 'prevs'
m_lerpStickPrev = m_lerpedStick;
m_keyJumpPrev = (m_rTrigger &gt; m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stop if game is paused
if(obj_gameManager.m_gamePaused || obj_gameManager.m_gameEnd)
    exit;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get the player's input

// Controller

m_lStickH = gamepad_axis_value(m_controllerId, gp_axislh);
m_lStickV = gamepad_axis_value(m_controllerId, gp_axislv);

m_rStickH = gamepad_axis_value(m_controllerId, gp_axisrh);
m_rStickV = gamepad_axis_value(m_controllerId, gp_axisrv);

m_lTrigger = gamepad_button_value(m_controllerId, gp_shoulderlb);
m_rTrigger = gamepad_button_value(m_controllerId, gp_shoulderrb);

m_buttonA = gamepad_button_check(m_controllerId, gp_face1);
m_buttonB = gamepad_button_check(m_controllerId, gp_face2);
m_buttonX = gamepad_button_check(m_controllerId, gp_face3);
m_buttonY = gamepad_button_check(m_controllerId, gp_face4);

m_buttonAPressed = gamepad_button_check_pressed(m_controllerId, gp_face1);
m_buttonBPressed = gamepad_button_check_pressed(m_controllerId, gp_face2);
m_buttonXPressed = gamepad_button_check_pressed(m_controllerId, gp_face3);
m_buttonYPressed = gamepad_button_check_pressed(m_controllerId, gp_face4);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign buttons

m_keyJump = (m_rTrigger &gt; m_controllerDeadzone &amp;&amp; !m_keyJumpPrev);
m_keyJumpHeld = (m_rTrigger &gt; m_controllerDeadzone);
m_keyAbility = m_buttonXPressed;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEBUG KEYBOARD INPUT

if (DEBUG_MODE &amp;&amp; m_playerId == 1)
{
    m_lStickH = (-keyboard_check(vk_left) + keyboard_check(vk_right));
    m_keyJump = keyboard_check_pressed(vk_up);
    m_keyJumpHeld = keyboard_check(vk_up);
    m_keyAbility = keyboard_check_pressed(vk_lcontrol);
    
    m_rStickH = (-keyboard_check(ord("A")) + keyboard_check(ord("D")));
    m_rStickV = (-keyboard_check(ord("W")) + keyboard_check(ord("S")));
    
    m_lTrigger = keyboard_check(vk_rshift);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update playerstates

// On the ground
if (place_meeting(x,y+1,obj_collider)) 
{
    if(!m_onGround)
    {
        // Set squishy landing
        m_imageXScale = 1.4;
        m_imageYScale = 0.7;
    }
    m_againstWall = false;
    m_onGround = true;
}
else 
{
    m_onGround = false;
    global.airTime[m_playerId]++;
    // Against a wall
   if ((place_meeting(x - 3,y, obj_collider)) || (place_meeting(x + 3,y, obj_collider)))
   {
      if (m_againstWall == false)
      { 
         m_jumps = 1; 
      }
      
     m_againstWall = true;
     m_wallDir = (-(place_meeting(x - m_wallDistance,y,obj_collider)) + (place_meeting(x + m_wallDistance,y,obj_collider)));
   }
   else 
   {
      m_againstWall = false;
      m_wallDir = 0;
   }
}

if (abs(m_lStickH) &lt; m_dashDanceMargin )
{
   m_dashDanceActive = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Calculate accelleration
//* and control speed in mid-air

var stick = m_lStickH
var inertia = 0;

if (m_onGround) // On the ground
{
    inertia = m_inertiaGround;
}

else // InAir
{ 
    inertia = m_inertiaAir;
}

m_lerpedStick = lerp(m_lerpedStick, stick, (inertia * global.timeScale));


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move to inputs

move = m_lerpedStick;
m_hsp = move * m_movespeed;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control gravity
if (m_againstWall)
{
   if (m_vsp &lt; m_maxFallSpeed / 4)
   {
      m_vsp += (global.grav * global.timeScale);
   }
}
else
{
   if (m_vsp &lt; m_maxFallSpeed) 
   { 
       m_vsp += (global.grav * global.timeScale);
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Jumping

if (m_onGround) // If the player is on the ground
{
   m_jumps = m_jumpsmax; // Reset the jump amount
}
else // Player is in the air
{
   if (m_jumps == m_jumpsmax) { m_jumps -=1; } // If jumps is equal to the max, subtract one
}

if ((m_keyJump) &amp;&amp; (m_jumps &gt; 0))
{
   m_jumps -= 1;
   m_vsp = -m_jumpspeed;
   global.jumps[m_playerId]++;
    
   if(m_jumps == 0) // Activate air-dash
   {
      m_hspFinal = 0;
      m_hsp = 0;
        
      if(m_lStickH != 0)
      { m_bodyAngle += (360 * sign(m_lStickH)); }
      else
      { m_bodyAngle += (360 * m_imageDirection); }
      
      m_playerState = m_playerStates.airDashing
      m_lerpedStick = (m_lStickH * m_airDashSpeed) * 0.7; 
      
      if (m_againstWall)
      {
         m_lerpedStick -= m_wallDir;
         m_vsp = -m_jumpspeed * 1.2;
      }      
      
      effect_create_below(ef_smoke, x, y + 16, 1, c_gray);
   }
   
   // Set squishy jump
   m_imageXScale = 0.6;
   m_imageYScale = 1.3;
}

if ((m_vsp &lt; 0) &amp;&amp; (!m_keyJumpHeld)) { 
    m_vsp = max(m_vsp, -m_jumpspeed / 3);  
}


m_hspFinal = m_hsp + m_hspCarry;
m_hspCarry = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control Dash Dance

if (m_onGround) // Check if the player is on the ground
{  
   if (m_dashDanceTimer &gt; 0) // Check if the timer is larger than 0
   {
      if(m_lStickH * -m_dashDancePrev &gt; m_dashDanceMargin) // Check if the current input is the same as the previous * -0.9
      {
         m_lerpedStick = sign(m_lStickH); // Apply the new velocity multiplier
      }
   
      m_dashDanceTimer -= global.timeScale; // Time the timer
   }
   
   if (abs(m_lerpedStick) &gt; m_dashDanceMargin &amp;&amp; !m_dashDanceActive) // Check if the velocity multiplier is higher then 0.9
   {
      m_dashDanceTimer = m_dashDanceWindow; // Set the timer
      m_dashDancePrev = sign(m_lStickH); // Set the old position of the stick to the current
      
      m_dashDanceActive = true;
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Warp room borders

if (x &lt; 0-32)
    { x += room_width+64; } 
if (x &gt; room_width+32)
    { x -= room_width+64; }
if (y &lt; 0-32)
    { y += room_height+64; }
if (y &gt; room_height+32)
    { y -= room_height+64; }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Collision
if (place_meeting(x + (m_hspFinal * global.timeScale), y, obj_collider))
{
    while(!place_meeting(x + sign(m_hspFinal), y, obj_collider))
    {
        x += sign(m_hspFinal);
    }
    
    m_hspFinal = 0;
    m_hsp = 0;
    m_lerpedStick = 0;
}

x += (m_hspFinal * global.timeScale);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical Collision
if (place_meeting(x, y + (m_vsp * global.timeScale), obj_collider))
{
    while(!place_meeting(x, y + sign(m_vsp), obj_collider))
    {
        y += sign(m_vsp);
    }
    if(!m_onGround) { m_bodyLandOffset += m_vsp; }
    m_vsp = 0;
}

y += (m_vsp * global.timeScale);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Activate ability


if(obj_gameManager.m_playerAbilityActive[m_playerId] == false)
{
    if(global.playerAbility[m_playerId] == 100)
    {
        effect_create_below(ef_smokeup, x, y, 0, global.playerColor[m_playerId]);
        
        if(m_keyAbility)
        {
            obj_gameManager.m_playerAbilityActive[m_playerId] = true;
            play_sound(snd_abilityActivate);
            global.abilitiesUsed[m_playerId]++;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control bow

var largStick = max(abs(m_rStickH), abs(m_rStickV))
var trigger = m_lTrigger;

// Check if active
if(largStick &gt; 0.5)
{ m_bowActive = true; }
else if(!m_arrowActive)
{ 
    m_bowActive = false;
    
    trigger = 0;
    m_triggerPrev = 0;
}

if(!m_arrowActive &amp;&amp; m_stringTimer &lt; 25)
{
    trigger = 0;
    m_triggerPrev = 0;
}

// Set arrow active
if(m_arrowForce == 0 &amp;&amp; m_triggerPrev != 0)
{ 
    if(!m_arrowActive) { play_sound(snd_StringStretch); }
    m_arrowActive = true; 
}

// Update force
m_arrowForce = lerp(m_arrowForce, m_triggerPrev, (0.2 * global.timeScale));

// Delta Check
if (m_bowDeltaTimer == m_bowDeltaMax)
{
    if ((trigger + m_bowDeltaThreshold) &lt; m_triggerPrev)
    {
        m_bowShoot = true;
    }
    
    m_triggerPrev = trigger;
    m_bowDeltaTimer = 0;
}
else
{
    m_bowDeltaTimer += 1;
    m_bowShoot = false;
}

// Calculate bow's angle
if(largStick &gt; 0.25)
{ 
    // Calcutate angle
    angle_next = point_direction(0, 0, m_rStickH, m_rStickV); // The angle where we need to go to
    angle_prev = m_bowAngle; // the last angle of the image
    angle_diff = angle_difference(angle_prev, angle_next); // get the difference between the angle
    
    angle_next = angle_prev - angle_diff; // convert the angle to a number outside of 0-360 if needed
    
    m_bowAngle = lerp(m_bowAngle, angle_next, 0.6 );
    
    //m_bowAngle = point_direction(0, 0, m_rStickH, m_rStickV); 
}


// Calculate distance
var distance = 16;
if(m_bowActive) { distance = 32; }

m_bowDistance = lerp(m_bowDistance, distance, (0.6 * global.timeScale));

// Position the bow
m_bowX = x + lengthdir_x(m_bowDistance, m_bowAngle);
m_bowY = y + lengthdir_y(m_bowDistance, m_bowAngle);

// Control shooting
if(m_arrowForce &gt; m_arrowForceMin &amp;&amp; m_arrowActive)
{
    if(m_holdTimer &gt; m_holdTimerMax &amp;&amp; m_bowShoot)
    {
        shoot_arrow(m_bowX, m_bowY, m_bowAngle, m_arrowForce, m_playerId);
        m_arrowActive = false;
        m_arrowForceOld = m_arrowForce;
        m_arrowForce = 0;
        global.arrowsFired[m_playerId]++;
    }
    
    m_holdTimer += global.timeScale;
}
else { m_holdTimer = 0; }

// Animate the string
if(!m_arrowActive)
{
    // Ease the string
    m_stringDistance = ease_out_elastic(m_stringTimer, ARROW_LENGTH * m_arrowForceOld, 
                                        -(ARROW_LENGTH * m_arrowForceOld), m_stringAnimTime);
    
    // time the timer
    if(m_stringTimer &lt; m_stringAnimTime)
    { m_stringTimer += global.timeScale; }
}
else if(m_arrowActive)
{ 
    m_stringTimer = 0;
    m_stringDistance = lerp(m_stringDistance, ARROW_LENGTH * m_arrowForce, (0.3 * global.timeScale)); 
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animate OLD
/*
// Lerp scale for squishyness
m_imageXScale = lerp(m_imageXScale, 1, 0.2);
m_imageYScale = lerp(m_imageYScale, 1, 0.2);

signMove = sign(move);

if (m_lStickH != 0 &amp;&amp; (m_onGround || m_againstWall)) { m_imageDirection = signMove; }
   
if (place_meeting(x,y+1,obj_collider)) // Player is on the ground
{
    if (abs(move) &gt; 0.5) 
    {
        m_spriteIndex = m_spriteRun; 
        m_imageSpeed = 0.25;
    }
    else 
    {
        m_spriteIndex = m_spriteIdle; 
        m_imageSpeed = 0.25;
    }
}
else // Player is in the air
{
     if (m_againstWall) { m_spriteIndex = m_spriteWallSlide;}
     else if (m_vsp &lt; 0) { m_spriteIndex = m_spriteJump; } 
     else { m_spriteIndex = m_spriteFall; }
}

if (!m_onGround)
{
    m_imageAngle = (25 * (move * -1));
}
else
{
    // Calcutate angle
    angle_next = 0  // The angle where we need to go to
    angle_prev = m_imageAngle; // the last angle of the image
    angle_diff = angle_difference(angle_prev,angle_next); // get the difference between the angle
    
    angle_next = angle_prev-angle_diff; // convert the angle to a number outside of 0-360 if needed
    
    m_imageAngle = lerp(m_imageAngle, angle_next, 0.6);
}

// Time the animation
m_imageIndex += m_imageSpeed;

if(m_imageIndex &gt; sprite_get_number(m_spriteIndex))
{
    m_imageIndex = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animate New

signMove = sign(move);

// Check which direction the player should face
if (m_lStickH != 0 &amp;&amp; (m_onGround || m_againstWall)) { m_imageDirection = signMove; }

// All the code here is for when the player faces right
// Check in which state the player is
if (m_onGround) // Player is on the ground
{
    if (abs(move) &gt; 0.1) // walking
    {   
        // Time the timer pretty fast 
        m_bodyOffSin += (0.20 * abs(move) * global.timeScale);
        m_legAngleSin = m_bodyOffSin; // The legs must time perfectly with the body
        
        // Calculate an offset which makes the body bounce
        m_bodyOffsetY = abs(sin(m_bodyOffSin) * 10) * -1;
        
        // Stick the legs to the body
        m_legROffsetY = m_bodyOffsetY;
        m_legLOffsetY = m_bodyOffsetY;
        
        // Animate the leg rotation
        m_legRAngle = sin(m_legAngleSin) * 70;
        m_legLAngle = sin(m_legAngleSin) * 70 * -1;
    }
    else // idle
    {   
        // Time the timer slowly 
        m_bodyOffSin += (0.05 * global.timeScale);
        
        // Calculate an offset
        // Do a quick lerp which makes the transition from walking look nicer
        m_bodyOffsetY = lerp(m_bodyOffsetY, sin(m_bodyOffSin) * 2, (0.3 * global.timeScale));
        
        // Set the leg offsets to zero
        m_legROffsetY = 0;
        m_legLOffsetY = 0;
        
        // Lerp the leg angles to zero
        m_legRAngle = lerp(m_legRAngle, 0, (0.33 * global.timeScale));
        m_legLAngle = lerp(m_legLAngle, 0, (0.33 * global.timeScale));
    }
    
    m_bodyAngle = lerp(m_bodyAngle, 0, (0.3 * global.timeScale));
}
else // Player is in the air
{
    if (m_againstWall) // Against wall
    {  
        // Set the leg offsets to zero
        m_legROffsetY = 0;
        m_legLOffsetY = 0;
        
        // Lerp the leg angles to zero
        m_legRAngle = lerp(m_legRAngle, -90, (0.33 * global.timeScale));
        m_legLAngle = lerp(m_legLAngle, 90, (0.33 * global.timeScale));
        
        m_bodyAngle = lerp(m_bodyAngle, 90 * m_wallDir, (0.3 * global.timeScale));
    }
    else // In-Air
    {         
        if(m_vsp &lt; 0) // player is moving up
        {
            // Set the leg offset dependend on the vertical speed
            m_legROffsetY = clamp(m_vsp * 0.3, -12, 4);
            m_legLOffsetY = clamp(m_vsp * 0.3 * -1, -12, 4);
            
            // Lerp the leg angles to zero
            m_legRAngle = lerp(m_legRAngle, 0, (0.2 * global.timeScale));
            m_legLAngle = lerp(m_legLAngle, 0, (0.2 * global.timeScale));
        }
        else // player is falling
        {
            m_legROffsetY = 0;
            m_legLOffsetY = 0;
            
            m_legRAngle = (m_vsp * 1.4 * -1);
            m_legLAngle = (m_vsp * 1.4);
        }
        // Lerp the offset to zero
        m_bodyOffsetY = lerp(m_bodyOffsetY, 0, (0.4 * global.timeScale));
        
        m_bodyAngle = lerp(m_bodyAngle, (25 * (move * -1)), (0.1 * global.timeScale));
    }
}

// Clamp the lerps!!
m_legRAngle = clamp(m_legRAngle, -90, 90);
m_legLAngle = clamp(m_legLAngle, -90, 90);
m_bodyLandOffset = lerp(m_bodyLandOffset, 0, 0.3);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Calc pos and rot's for the sprites

// Set the right values for if the player is facing left
if(m_imageDirection == 1) // Player faces right, nothing changes
{
    m_legLYOff = m_legLOffsetY;
    m_legRYOff = m_legROffsetY;

}
else // Player faces left, values need to be flipped
{
    m_legLYOff = m_legROffsetY;
    m_legRYOff = m_legLOffsetY;
}

m_legLA = m_legLAngle + m_bodyAngle;
m_legRA = m_legRAngle + m_bodyAngle;

// Calculate leg positions based on bodyAngle
// Calculate the vertical offset
m_legBX = x + lengthdir_x(12, m_bodyAngle - 90);
m_legBY = y + lengthdir_y(12, m_bodyAngle - 90);

// Add the horizontal offset
m_legRX = m_legBX + lengthdir_x(8, m_bodyAngle - 180);
m_legRY = m_legBY + lengthdir_y(8, m_bodyAngle - 180);

m_legLX = m_legBX + lengthdir_x(8, m_bodyAngle);
m_legLY = m_legBY + lengthdir_y(8, m_bodyAngle);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Save positions for the trail
if(obj_gameManager.m_playerKillStreak[m_playerId] &gt; BOUNTY_THRESHOLD)
{
    // Insert the new values
    m_imageDirectionT[0] = m_imageDirection;
    
    // Left leg
    m_legRXT[0] = m_legRX;
    m_legRYT[0] = m_legRY;
    m_legLYOffT[0] = m_legLYOff;
    m_legRAT[0] = m_legRA;
    
    // Right leg
    m_legLXT[0] = m_legLX;
    m_legLYT[0] = m_legLY;
    m_legRYOffT[0] = m_legRYOff;
    m_legLAT[0] = m_legLA;
    
    // Body
    m_xT[0] = x;
    m_yT[0] = y;
    m_bodyOffsetYT[0] = m_bodyOffsetY;
    m_bodyLandOffsetT[0] = m_bodyLandOffset;
    m_bodyAngleT[0] = m_bodyAngle;
    
    // Shift the values
    for (i = m_trailArrayLength; i &gt; 0; i--)
    {
        m_imageDirectionT[i] = m_imageDirectionT[i-1];
        
        // Left leg
        m_legRXT[i] = m_legRXT[i-1];
        m_legRYT[i] = m_legRYT[i-1];
        m_legLYOffT[i] = m_legLYOffT[i-1];
        m_legRAT[i] = m_legRAT[i-1];
        
        // Right leg
        m_legLXT[i] = m_legLXT[i-1];
        m_legLYT[i] = m_legLYT[i-1];
        m_legRYOffT[i] = m_legRYOffT[i-1];
        m_legLAT[i] = m_legLAT[i-1];
        
        // Body
        m_xT[i] = m_xT[i-1];
        m_yT[i] = m_yT[i-1];
        m_bodyOffsetYT[i] = m_bodyOffsetYT[i-1];
        m_bodyLandOffsetT[i] = m_bodyLandOffsetT[i-1];
        m_bodyAngleT[i] = m_bodyAngleT[i-1];
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Create" event</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize variables

//m_playerId

// Player's states
m_playerState = m_playerStates.normal;

m_onGround = false;
m_againstWall = false;

enum m_playerStates 
{
    normal,
    airDashing
}


// Movement
m_hsp = 0;
m_hspCarry = 0;
m_hspFinal = 0;

m_accelation = 0;           // This value lerps to 1 if waling anf to 0 if staning still
m_accelationAmount = 0.1;   // The lerp interpolation for acceleration

m_vsp = 0;
m_movespeed = 12;
m_moveDir = 0;

m_inertiaGround = 0.2;
m_inertiaAir = 0.07;
m_inertiaDash = 0.02;

m_lerpedStick = 0;

// Jumping
m_jumps = 0;
m_jumpsmax = 2;
m_jumpspeed = 18;
m_maxFallSpeed = 44;

m_airDashSpeed = 2.2;   // lerpStick gets multiplied with this value

// Dash dancing
m_dashDanceWindow = 20;
m_dashDanceTimer = 0;
m_dashDancePrev = 0;
m_dashDanceActive = false;
m_dashDanceMargin = 0.9;


// Wallclinging
m_wallDir = 0;       // The direction of the wall the player is clinging to (either -1 or 1)
m_wallDistance = 3;  // The distance for the player to cling to a wall

// Bow
m_bowActive = false;
m_bowCharge = 0;
m_bowFireRate = 10;
m_bowDistance = 0;
m_bowShoot = false;

m_bowX = x;
m_bowY = y;
m_bowAngle = 0;

m_holdTimerMax = 4;
m_holdTimer = 0;

m_triggerPrev = 0;
m_bowDeltaMax = 3
m_bowDeltaTimer = 0;
m_bowDeltaThreshold = 0.3;

m_arrowActive = false;
m_arrowForce = 0;
m_arrowForceMin = 0.3;
m_arrowForceOld = 0;

m_stringDistance = 0;
m_stringPixelOffset = 2;
m_stringAnimTime = 30;
m_stringTimer = 0;

// Sounds
m_WallSlideSound = 0;

// Keys
m_keyJump = false;
m_keyJumpPrev = false;
m_keyJumpHeld = false;
m_keyAbility = false;

// Animation
m_spriteBody = noone;
m_spriteLeg = noone;

m_bodyOffsetY = 0;
m_bodyAngle = 0;
m_bodyLandOffset = 0;

m_legLOffsetY = 0;
m_legROffsetY = 0;

m_legLAngle = 0;
m_legRAngle = 0;

m_bodyOffSin = 0;
m_legOffSin = 0;
m_legAngleSin = 0;

m_headSprite = noone;
m_legSprite = noone;

m_imageDirection = 1;

// Variables for leg positions, yOffset and Angle
m_legLX = 0; 
m_legLY = 0; 
m_legRX = 0; 
m_legRY = 0; 
m_legLYOff = 0; 
m_legRYOff = 0; 
m_legLA = 0; 
m_legRA = 0;

// Variables for calculating the position of the legs
m_xOff = 0; 
m_yOff = 0; 
m_legBX = 0; 
m_legBY = 0; 
m_length = 0; 
m_dir = 0;

// And for the hat
m_hatBX = 0;
m_hatBY = 0;

m_hatX = 0;
m_hatY = 0;

// Arrays for the trail
m_trailArrayLength = 10;

for (i = 0; i &lt; m_trailArrayLength; i++)
{
    m_imageDirectionT[i] = 0;
    
    // Left leg
    m_legRXT[i] = 0;
    m_legRYT[i] = 0;
    m_legLYOffT[i] = 0;
    m_legRAT[i] = 0;
    
    // Right leg
    m_legLXT[i] = 0;
    m_legLYT[i] = 0;
    m_legRYOffT[i] = 0;
    m_legLAT[i] = 0;
    
    // Body
    m_xT[i] = 0;
    m_yT[i] = 0;
    m_bodyOffsetYT[i] = 0;
    m_bodyLandOffsetT[i] = 0;
    m_bodyAngleT[i] = 0;
}

// Controller
m_controllerId = 0;
m_controllerDeadzone = 0.3;

m_lStickH = 0;
m_lStickV = 0;

m_rStickH = 0;
m_rStickV = 0;

m_lTrigger = 0;
m_rTrigger = 0;

m_buttonA = false;
m_buttonB = false;
m_buttonX = false;
m_buttonY = false;

m_buttonAPressed = false;
m_buttonBPressed = false;
m_buttonXPressed = false;
m_buttonYPressed = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize player
m_controllerId = global.playerGamepadID[m_playerId];
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get the sprites

m_headSprite = head_sprite(global.playerHead[m_playerId]);
m_legSprite = leg_sprite(global.playerLeg[m_playerId]);
m_spriteHat = hat_sprite(global.playerHat[m_playerId]);
m_spriteBow = bow_sprite(global.playerBow[m_playerId]);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize controller

// Set the deadzone
gamepad_set_axis_deadzone(m_controllerId, m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign character specific values

m_hatHeight = get_hat_height(global.playerHead[m_playerId]);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw debug info
//if (m_playerId != 0)
   exit;

draw_text_debug(0, "lStick: h " + string(m_lStickH));
draw_text_debug(1, "lerpstick: " + string(m_lerpedStick));
draw_text_debug(2, "jumpStick: " + string(m_rTrigger));
draw_text_debug(3, "hsp: " + string(m_hsp));
draw_text_debug(4, "vsp: " + string(m_vsp));
draw_text_debug(5, "playerstate: " + string(m_playerState));
draw_text_debug(6, "against wall: " + string(m_againstWall));
draw_text_debug(7, "DDance timer: " + string(m_dashDanceTimer));
draw_text_debug(8, "DDance prev: " + string(m_dashDancePrev));
draw_text_debug(9, "Arrow count: " + string(instance_number(obj_arrow)));
draw_text_debug(10, "rStick h: " + string(m_rStickH));
draw_text_debug(11, "rStick v: " + string(m_rStickV));
draw_text_debug(12, "arrowForce: " + string(m_arrowForce));
draw_text_debug(13, "arrowForceOld: " + string(m_arrowForceOld));
draw_text_debug(14, "triggerPrev: " + string(m_triggerPrev));
draw_text_debug(15, "stringTimer: " + string(m_stringTimer));
draw_text_debug(16, "stringDistance: " + string(m_stringDistance));
draw_text_debug(17, "arrowActive: " + string(m_arrowActive));
draw_text_debug(18, "lTrigger: " + string(m_lTrigger));
draw_text_debug(19, "bowDeltaTimer: " + string(m_bowDeltaTimer));
draw_text_debug(20, "view_xview: " + string(view_xview));
draw_text_debug(21, "view_yview: " + string(view_yview));
draw_text_debug(22, "view_wview: " + string(view_wview));
draw_text_debug(23, "view_hview: " + string(view_hview));
draw_text_debug(24, "player x: " + string(x));
draw_text_debug(25, "player y: " + string(y));
draw_text_debug(26, "bodyAngle: " + string(m_bodyAngle));
draw_text_debug(27, "timeScale: " + string(global.timeScale));
draw_text_debug(28, "bodyLandOffset: " + string(m_bodyLandOffset));
draw_text_debug(29, "playerAbility: " + string(global.playerAbility[0]));
draw_text_debug(30, "bowAngle: " + string(m_bowAngle));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player trail
if(obj_gameManager.m_playerKillStreak[m_playerId] &gt; BOUNTY_THRESHOLD)
{
    var col =  global.playerColor[m_playerId]
    
    d3d_set_fog(true, col, 0, 0)
    
    for (i = m_trailArrayLength-1; i &gt;= 0; i -= 1)
    {
        // Left leg
        draw_sprite_ext(m_legSprite, 0, m_legRXT[i], m_legRYT[i] + m_legLYOffT[i], 
        m_imageDirection, 1, m_legRAT[i], col, 0.5);
        
        // Right leg
        draw_sprite_ext(m_legSprite, 0, m_legLXT[i], m_legLYT[i] + m_legRYOffT[i], 
            m_imageDirectionT[i], 1, m_legLAT[i], col, 0.5);
        
        // Draw the body
        draw_sprite_ext(m_headSprite, 0, m_xT[i], m_yT[i] + m_bodyOffsetYT[i] + m_bodyLandOffsetT[i],
            m_imageDirectionT[i], 1, m_bodyAngleT[i], col, 0.5);
    }
    
    d3d_set_fog(0, 0, 0, 0)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player

//draw_player_outline(m_playerId, 1)

// make inversed if ability is active
var invrs = obj_gameManager.m_playerAbilityActive[m_playerId];
if(invrs)
{
    draw_set_blend_mode_ext(bm_inv_dest_colour, bm_zero);
    draw_rectangle_colour(x-48/2, y-48/2, x+48/2, y+48/2, c_white,c_white,c_white,c_white,false);
    draw_set_blend_mode(bm_normal); 
}

// Draw the player
// Left leg
draw_sprite_ext(m_legSprite, 0, m_legRX, m_legRY + m_legLYOff, 
    m_imageDirection, 1, m_legRA, c_white, 1);
    
// Right leg
draw_sprite_ext(m_legSprite, 0, m_legLX, m_legLY + m_legRYOff, 
    m_imageDirection, 1, m_legLA, c_white, 1);

// Draw the body
draw_sprite_ext(m_headSprite, 0, x, y + m_bodyOffsetY + m_bodyLandOffset,
    m_imageDirection, 1, m_bodyAngle, c_white, 1);

if(invrs)
{
    draw_set_blend_mode_ext(bm_inv_dest_colour, bm_zero);
    draw_rectangle_colour(x-48/2, y-48/2, x+48/2, y+48/2, c_white,c_white,c_white,c_white,false);
    draw_set_blend_mode(bm_normal);
}
    
// Draw the hat
draw_player_hat(0, 0, c_white);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the bow

// Calculate string positions
var x1, y1, x2, y2, x3, y3;
var height = sprite_get_height(m_spriteBow) / 2 - m_stringPixelOffset;
var flip = 1
if(within(m_bowAngle mod 360, 90, 270)) { flip = -1; }

x1 = m_bowX + lengthdir_x(height ,m_bowAngle - 90);
y1 = m_bowY + lengthdir_y(height ,m_bowAngle - 90);

x2 = m_bowX + lengthdir_x(height ,m_bowAngle + 90);
y2 = m_bowY + lengthdir_y(height ,m_bowAngle + 90);

x3 = m_bowX + lengthdir_x(m_stringDistance, m_bowAngle + 180);
y3 = m_bowY + lengthdir_y(m_stringDistance, m_bowAngle + 180);

// Draw the string
draw_set_color(c_white);

middle = draw_bezier(x1, y1, x3, y3, x2, y2);

// Draw the bow sprite
draw_sprite_ext(m_spriteBow, 0, m_bowX, m_bowY, 1, flip, m_bowAngle, c_white, 1);

// Draw a 'fake' arrow, but only if the arrow isn't shot
if(m_arrowActive)
{
    var x1, y1, x2, y2;
    x1 = middle[0]
    y1 = middle[1]
    
    x2 = x1 + lengthdir_x(ARROW_LENGTH, m_bowAngle)
    y2 = y1 + lengthdir_y(ARROW_LENGTH, m_bowAngle)
    
    draw_line_width(x1, y1, x2, y2, ARROW_WIDTH);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
