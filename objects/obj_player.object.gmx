<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>msk_player</maskName>
  <events>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign 'prevs'
m_lerpStickPrev = m_lerpedStick;
m_keyJumpPrev = (m_rTrigger &gt; m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get the player's input

// Controller

m_lStickH = gamepad_axis_value(m_controllerId, gp_axislh);
m_lStickV = gamepad_axis_value(m_controllerId, gp_axislv);

m_rStickH = gamepad_axis_value(m_controllerId, gp_axisrh);
m_rStickV = gamepad_axis_value(m_controllerId, gp_axisrv);

m_lTrigger = gamepad_button_value(m_controllerId, gp_shoulderlb);
m_rTrigger = gamepad_button_value(m_controllerId, gp_shoulderrb);

m_buttonA = gamepad_button_check(m_controllerId, gp_face1);
m_buttonB = gamepad_button_check(m_controllerId, gp_face2);
m_buttonX = gamepad_button_check(m_controllerId, gp_face3);
m_buttonY = gamepad_button_check(m_controllerId, gp_face4);

m_buttonAPressed = gamepad_button_check_pressed(m_controllerId, gp_face1);
m_buttonBPressed = gamepad_button_check_pressed(m_controllerId, gp_face2);
m_buttonXPressed = gamepad_button_check_pressed(m_controllerId, gp_face3);
m_buttonYPressed = gamepad_button_check_pressed(m_controllerId, gp_face4);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign buttons

m_keyJump = (m_rTrigger &gt; m_controllerDeadzone &amp;&amp; !m_keyJumpPrev);
m_keyJumpHeld = (m_rTrigger &gt; m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEBUG KEYBOARD INPUT
if (m_playerId == 0)
{
   if(!gamepad_is_connected(0))
   {
      m_lStickH = (-keyboard_check(vk_left) + keyboard_check(vk_right));
      m_keyJump = keyboard_check_pressed(vk_up);
      m_keyJumpHeld = keyboard_check(vk_up);
      
      m_rStickH = (-keyboard_check(ord("A")) + keyboard_check(ord("D")));
      m_rStickV = (-keyboard_check(ord("W")) + keyboard_check(ord("S")));
      
      m_lTrigger = keyboard_check(vk_rshift);
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update playerstates

// On the ground
if (place_meeting(x,y+1,obj_collider)) 
{
    if(!m_onGround)
    {
        // Set squishy landing
        m_imageXScale = 1.4;
        m_imageYScale = 0.7;
        
        m_bodyOffsetY += 12;
    }
    m_againstWall = false;
    m_onGround = true;
}
else 
{
    m_onGround = false;
    
    // Against a wall
   if ((place_meeting(x - 3,y, obj_collider)) || (place_meeting(x + 3,y, obj_collider)))
   {
      if (m_againstWall == false)
      { 
         m_jumps = 1; 
      }
      
     m_againstWall = true;
     m_wallDir = (-(place_meeting(x - m_wallDistance,y,obj_collider)) + (place_meeting(x + m_wallDistance,y,obj_collider)));
   }
   else 
   {
      m_againstWall = false;
      m_wallDir = 0;
   }
}

if (abs(m_lStickH) &lt; m_dashDanceMargin )
{
   m_dashDanceActive = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Calculate accelleration
//* and control speed in mid-air

var stick = m_lStickH
var inertia = 0;

if (m_onGround) // On the ground
{
    inertia = m_inertiaGround;
}

else // InAir
{ 
    inertia = m_inertiaAir;
}

m_lerpedStick = lerp(m_lerpedStick, stick, inertia);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move to inputs

move = m_lerpedStick;
m_hsp = move * m_movespeed;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control gravity
if (m_againstWall)
{
   if (m_vsp &lt; m_maxFallSpeed / 4)
   {
      m_vsp += m_grav
   }
}
else
{
   if (m_vsp &lt; m_maxFallSpeed) 
   { 
       m_vsp += m_grav; 
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Jumping

if (m_onGround) // If the player is on the ground
{
   m_jumps = m_jumpsmax; // Reset the jump amount
}
else // Player is in the air
{
   if (m_jumps == m_jumpsmax) { m_jumps -=1; } // If jumps is equal to the max, subtract one
}

if ((m_keyJump) &amp;&amp; (m_jumps &gt; 0))
{
   m_jumps -= 1;
   m_vsp = -m_jumpspeed;
    
   if(m_jumps == 0) // Activate air-dash
   {
      m_hspFinal = 0;
      m_hsp = 0;
        
      if(m_lStickH != 0)
      { m_bodyAngle += (360 * sign(m_lStickH)); }
      else
      { m_bodyAngle += (360 * sign(move)); }
      
      m_playerState = m_playerStates.airDashing
      m_lerpedStick = (m_lStickH * m_airDashSpeed) * 0.7; 
      
      if (m_againstWall)
      {
         m_lerpedStick -= m_wallDir;
         m_vsp = -m_jumpspeed * 1.2;
      }
      
      
      
      effect_create_below(ef_smoke, x, y + 16, 1, c_gray);
   }
   
   // Set squishy jump
   m_imageXScale = 0.6;
   m_imageYScale = 1.3;
}

if ((m_vsp &lt; 0) &amp;&amp; (!m_keyJumpHeld)) { 
    m_vsp = max(m_vsp, -m_jumpspeed / 3);  
}


m_hspFinal = m_hsp + m_hspCarry;
m_hspCarry = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control Dash Dance

if (m_onGround) // Check if the player is on the ground
{  
   if (m_dashDanceTimer &gt; 0) // Check if the timer is larger than 0
   {
      if(m_lStickH * -m_dashDancePrev &gt; m_dashDanceMargin) // Check if the current input is the same as the previous * -0.9
      {
         m_lerpedStick = sign(m_lStickH); // Apply the new velocity multiplier
      }
   
      m_dashDanceTimer--; // Time the timer
   }
   
   if (abs(m_lerpedStick) &gt; m_dashDanceMargin &amp;&amp; !m_dashDanceActive) // Check if the velocity multiplier is higher then 0.9
   {
      m_dashDanceTimer = m_dashDanceWindow; // Set the timer
      m_dashDancePrev = sign(m_lStickH); // Set the old position of the stick to the current
      
      m_dashDanceActive = true;
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Collision
if (place_meeting(x+m_hspFinal,y,obj_collider))
{
    while(!place_meeting(x+sign(m_hspFinal), y, obj_collider))
    {
        x += sign(m_hspFinal);
    }
    
    m_hspFinal = 0;
    m_hsp = 0;
    m_lerpedStick = 0;
}

x += m_hspFinal;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical Collision
if (place_meeting(x,y+m_vsp,obj_collider))
{
    while(!place_meeting(x, y+sign(m_vsp), obj_collider))
    {
        y += sign(m_vsp);
    }
    m_vsp = 0;
}

y += m_vsp;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control bow

var largStick = max(abs(m_rStickH), abs(m_rStickV))
var trigger = m_lTrigger;

// Check if active
if(largStick &gt; 0.5)
{ m_bowActive = true; }
else 
{ 
    m_bowActive = false;
    
    trigger = 0;
    m_triggerPrev = 0;
}

if(!m_arrowActive &amp;&amp; m_stringTimer &lt; 25)
{
    trigger = 0;
    m_triggerPrev = 0;
}

// Set arrow active
if(m_arrowForce == 0 &amp;&amp; m_triggerPrev != 0)
{ m_arrowActive = true; }

// Update force
m_arrowForce = lerp(m_arrowForce, m_triggerPrev, 0.2);

// Delta Check
if (m_bowDeltaTimer == m_bowDeltaMax)
{
    if ((trigger + m_bowDeltaThreshold) &lt; m_triggerPrev)
    {
        m_bowShoot = true;
    }
    
    m_triggerPrev = trigger;
    m_bowDeltaTimer = 0;
}
else
{
    m_bowDeltaTimer++;
    m_bowShoot = false;
}

// Calculate bow's angle
if(largStick &gt; 0.25)
{ m_bowAngle = point_direction(0, 0, m_rStickH, m_rStickV); }


// Calculate distance
var distance = 16;
if(m_bowActive) { distance = 32; }

m_bowDistance = lerp(m_bowDistance, distance, 0.3);

// Position the bow
m_bowX = x + lengthdir_x(m_bowDistance, m_bowAngle);
m_bowY = y + lengthdir_y(m_bowDistance, m_bowAngle);

// Control shooting
if(m_arrowForce &gt; m_arrowForceMin &amp;&amp; m_arrowActive)
{
    if(m_holdTimer &gt; m_holdTimerMax &amp;&amp; m_bowShoot)
    {
        shoot_arrow(m_bowX, m_bowY, m_bowAngle, m_arrowForce, m_playerId);
        m_arrowActive = false;
        m_arrowForceOld = m_arrowForce;
        m_arrowForce = 0;
    }
    
    m_holdTimer++;
}
else { m_holdTimer = 0; }

// Animate the string
if(!m_arrowActive)
{
    // Ease the string
    m_stringDistance = ease_out_elastic(m_stringTimer, ARROW_LENGTH * m_arrowForceOld, 
                                        -(ARROW_LENGTH * m_arrowForceOld), m_stringAnimTime);
    
    // time the timer
    if(m_stringTimer &lt; m_stringAnimTime)
    { m_stringTimer++; }
}
else if(m_arrowActive)
{ 
    m_stringTimer = 0;
    m_stringDistance = lerp(m_stringDistance, ARROW_LENGTH * m_arrowForce, 0.3); 
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animate OLD
/*
// Lerp scale for squishyness
m_imageXScale = lerp(m_imageXScale, 1, 0.2);
m_imageYScale = lerp(m_imageYScale, 1, 0.2);

signMove = sign(move);

if (m_lStickH != 0 &amp;&amp; (m_onGround || m_againstWall)) { m_imageDirection = signMove; }
   
if (place_meeting(x,y+1,obj_collider)) // Player is on the ground
{
    if (abs(move) &gt; 0.5) 
    {
        m_spriteIndex = m_spriteRun; 
        m_imageSpeed = 0.25;
    }
    else 
    {
        m_spriteIndex = m_spriteIdle; 
        m_imageSpeed = 0.25;
    }
}
else // Player is in the air
{
     if (m_againstWall) { m_spriteIndex = m_spriteWallSlide;}
     else if (m_vsp &lt; 0) { m_spriteIndex = m_spriteJump; } 
     else { m_spriteIndex = m_spriteFall; }
}

if (!m_onGround)
{
    m_imageAngle = (25 * (move * -1));
}
else
{
    // Calcutate angle
    angle_next = 0  // The angle where we need to go to
    angle_prev = m_imageAngle; // the last angle of the image
    angle_diff = angle_difference(angle_prev,angle_next); // get the difference between the angle
    
    angle_next = angle_prev-angle_diff; // convert the angle to a number outside of 0-360 if needed
    
    m_imageAngle = lerp(m_imageAngle, angle_next, 0.6);
}

// Time the animation
m_imageIndex += m_imageSpeed;

if(m_imageIndex &gt; sprite_get_number(m_spriteIndex))
{
    m_imageIndex = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animate New

signMove = sign(move);

// Check which direction the player should face
if (m_lStickH != 0 &amp;&amp; (m_onGround || m_againstWall)) { m_imageDirection = signMove; }

// All the code here is for when the player faces right
// Check in which state the player is
if (place_meeting(x,y+1,obj_collider)) // Player is on the ground
{
    if (abs(move) &gt; 0.1) // walking
    {   
        // Time the timer pretty fast 
        m_bodyOffSin += 0.21 * abs(move);
        m_legAngleSin = m_bodyOffSin; // The legs must time perfectly with the body
        
        // Calculate an offset which makes the body bounce
        m_bodyOffsetY = abs(sin(m_bodyOffSin) * 7.5) * -1;
        
        // Stick the legs to the body
        m_legROffsetY = m_bodyOffsetY;
        m_legLOffsetY = m_bodyOffsetY;
        
        // Animate the leg rotation
        m_legRAngle = sin(m_legAngleSin) * 70;
        m_legLAngle = sin(m_legAngleSin) * 70 * -1;
    }
    else // idle
    {   
        // Time the timer slowly 
        m_bodyOffSin += 0.05;
        
        // Calculate an offset
        // Do a quick lerp which makes the transition from walking look nicer
        m_bodyOffsetY = lerp(m_bodyOffsetY, sin(m_bodyOffSin) * 2, 0.3);
        
        // Set the leg offsets to zero
        m_legROffsetY = 0;
        m_legLOffsetY = 0;
        
        // Lerp the leg angles to zero
        m_legRAngle = lerp(m_legRAngle, 0, 0.33);
        m_legLAngle = lerp(m_legLAngle, 0, 0.33);
    }
    
    m_bodyAngle = lerp(m_bodyAngle, 0, 0.3);
}
else // Player is in the air
{
    if (m_againstWall) // Against wall
    {  
        // Set the leg offsets to zero
        m_legROffsetY = 0;
        m_legLOffsetY = 0;
        
        // Lerp the leg angles to zero
        m_legRAngle = lerp(m_legRAngle, -90, 0.33);
        m_legLAngle = lerp(m_legLAngle, 90, 0.33);
        
        m_bodyAngle = lerp(m_bodyAngle, 90 * m_wallDir, 0.3);
    }
    else // In-Air
    {         
        if(m_vsp &lt; 0) // player is moving up
        {
            // Set the leg offset dependend on the vertical speed
            m_legROffsetY = clamp(m_vsp * 0.3, -12, 4);
            m_legLOffsetY = clamp(m_vsp * 0.3 * -1, -12, 4);
            
            // Lerp the leg angles to zero
            m_legRAngle = lerp(m_legRAngle, 0, 0.2);
            m_legLAngle = lerp(m_legLAngle, 0, 0.2);
        }
        else // player is falling
        {
            m_legROffsetY = 0;
            m_legLOffsetY = 0;
            
            m_legRAngle = (m_vsp * 1.4 * -1);
            m_legLAngle = (m_vsp * 1.4);
        }
        // Lerp the offset to zero
        m_bodyOffsetY = lerp(m_bodyOffsetY, 0, 0.4);
        
        m_bodyAngle = lerp(m_bodyAngle, (25 * (move * -1)), 0.1);
    }
}

// Clamp the lerps!!
m_legRAngle = clamp(m_legRAngle, -90, 90);
m_legLAngle = clamp(m_legLAngle, -90, 90);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Create" event</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize variables

m_grav = 0.8;

// Player's states
m_playerState = m_playerStates.normal;

m_onGround = false;
m_againstWall = false;

enum m_playerStates 
{
    normal,
    airDashing
}


// Movement
m_hsp = 0;
m_hspCarry = 0;
m_hspFinal = 0;

m_accelation = 0;           // This value lerps to 1 if waling anf to 0 if staning still
m_accelationAmount = 0.1;   // The lerp interpolation for acceleration

m_vsp = 0;
m_movespeed = 12;
m_moveDir = 0;

m_inertiaGround = 0.2;
m_inertiaAir = 0.07;
m_inertiaDash = 0.02;

m_lerpedStick = 0;

// Jumping
m_jumps = 0;
m_jumpsmax = 2;
m_jumpspeed = 18;
m_maxFallSpeed = 30;

m_airDashSpeed = 2.2;   // lerpStick gets multiplied with this value

// Dash dancing
m_dashDanceWindow = 20;
m_dashDanceTimer = 0;
m_dashDancePrev = 0;
m_dashDanceActive = false;
m_dashDanceMargin = 0.9;


// Wallclinging
m_wallDir = 0;       // The direction of the wall the player is clinging to (either -1 or 1)
m_wallDistance = 3;  // The distance for the player to cling to a wall

// Bow
m_bowActive = false;
m_bowCharge = 0;
m_bowFireRate = 10;
m_bowDistance = 0;
m_bowShoot = false;

m_bowX = x;
m_bowY = y;
m_bowAngle = 0;

m_holdTimerMax = 4;
m_holdTimer = 0;

m_triggerPrev = 0;
m_bowDeltaMax = 3
m_bowDeltaTimer = 0;
m_bowDeltaThreshold = 0.3;

m_arrowActive = false;
m_arrowForce = 0;
m_arrowForceMin = 0.3;
m_arrowForceOld = 0;

m_stringDistance = 0;
m_stringPixelOffset = 2;
m_stringAnimTime = 30;
m_stringTimer = 0;

// Sounds
m_WallSlideSound = 0;

// Keys
m_keyJump = false;
m_keyJumpPrev = false;
m_keyJumpHeld = false;

// Animation
m_spriteBody = noone;
m_spriteLeg = noone;

m_bodyOffsetY = 0;
m_bodyAngle = 0;

m_legLOffsetY = 0;
m_legROffsetY = 0;

m_legLAngle = 0;
m_legRAngle = 0;

m_bodyOffSin = 0;
m_legOffSin = 0;
m_legAngleSin = 0;

m_headSprite = noone;
m_legSprite = noone;

m_imageDirection = 1;

// Controller
m_controllerId = 0;
m_controllerDeadzone = 0.3;

m_lStickH = 0;
m_lStickV = 0;

m_rStickH = 0;
m_rStickV = 0;

m_lTrigger = 0;
m_rTrigger = 0;

m_buttonA = false;
m_buttonB = false;
m_buttonX = false;
m_buttonY = false;

m_buttonAPressed = false;
m_buttonBPressed = false;
m_buttonXPressed = false;
m_buttonYPressed = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize player
m_controllerId = m_playerId;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get the player sprite

switch(global.playerSprite[m_playerId])
{
    case 0:
        m_headSprite = spr_head2;
        m_legSprite = spr_leg1;
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get the hat sprite

switch(global.playerHat[m_playerId])
{
    case 0:
        m_spriteHat = spr_hats;
        break;
    
    case 1:
        m_spriteHat = spr_hat1;
        break;
    
    case 2:
        m_spriteHat = spr_hat2;
        break;
        
    case 3:
        m_spriteHat = spr_hat3;
        break;
        
    case 4:
        m_spriteHat = spr_hat4;
        break;
        
    case 5:
        m_spriteHat = spr_hat5;
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize controller

// Set the deadzone
gamepad_set_axis_deadzone(m_controllerId, m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign character specific values

m_spriteBow = spr_bow;

m_hatHeight = get_hat_height(global.playerSprite[m_playerId]);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw debug info
if (m_playerId != 0)
   exit;

draw_text_debug(0, "lStick: h " + string(m_lStickH));
draw_text_debug(1, "lerpstick: " + string(m_lerpedStick));
draw_text_debug(2, "jumpStick: " + string(m_rTrigger));
draw_text_debug(3, "hsp: " + string(m_hsp));
draw_text_debug(4, "vsp: " + string(m_vsp));
draw_text_debug(5, "playerstate: " + string(m_playerState));
draw_text_debug(6, "against wall: " + string(m_againstWall));
draw_text_debug(7, "DDance timer: " + string(m_dashDanceTimer));
draw_text_debug(8, "DDance prev: " + string(m_dashDancePrev));
draw_text_debug(9, "Arrow count: " + string(instance_number(obj_arrow)));
draw_text_debug(10, "rStick h: " + string(m_rStickH));
draw_text_debug(11, "rStick v: " + string(m_rStickV));
draw_text_debug(12, "arrowForce: " + string(m_arrowForce));
draw_text_debug(13, "arrowForceOld: " + string(m_arrowForceOld));
draw_text_debug(14, "triggerPrev: " + string(m_triggerPrev));
draw_text_debug(15, "stringTimer: " + string(m_stringTimer));
draw_text_debug(16, "stringDistance: " + string(m_stringDistance));
draw_text_debug(17, "arrowActive: " + string(m_arrowActive));
draw_text_debug(18, "lTrigger: " + string(m_lTrigger));
draw_text_debug(19, "bowDeltaTimer: " + string(m_bowDeltaTimer));
draw_text_debug(20, "view_xview: " + string(view_xview));
draw_text_debug(21, "view_yview: " + string(view_yview));
draw_text_debug(22, "view_wview: " + string(view_wview));
draw_text_debug(23, "view_hview: " + string(view_hview));
draw_text_debug(24, "player x: " + string(x));
draw_text_debug(25, "player y: " + string(y));
draw_text_debug(26, "bodyAngle: " + string(m_bodyAngle));




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player

// Variables for leg positions, yOffset and Angle
var legLX, legLY, legRX, legRY, legLYOff, legRYOff, legLA, legRA;
// Variables for calculating the position of the legs
var xOff, yOff, legBX, legBY, length, dir;

// Set the right values for if the player is facing left
if(m_imageDirection == 1) // Player faces right, nothing changes
{
    legLYOff = m_legLOffsetY;
    legRYOff = m_legROffsetY;

}
else // Player faces left, values need to be flipped
{
    legLYOff = m_legROffsetY;
    legRYOff = m_legLOffsetY;
}

legLA = m_legLAngle + m_bodyAngle;
legRA = m_legRAngle + m_bodyAngle;

// Calculate leg positions based on bodyAngle using lengthdir
xoff = 8; 
yoff = 4;

// Calculate the vertical offset
legBX = x + lengthdir_x(12, m_bodyAngle - 90);
legBY = y + lengthdir_y(12, m_bodyAngle - 90);

// Add the horizontal offset
legRX = legBX + lengthdir_x(8, m_bodyAngle - 180);
legRY = legBY + lengthdir_y(8, m_bodyAngle - 180);

legLX = legBX + lengthdir_x(8, m_bodyAngle);
legLY = legBY + lengthdir_y(8, m_bodyAngle);



// Draw the legs
// Left leg
draw_sprite_ext(m_legSprite, 0, legRX, legRY + legLYOff, 
    m_imageDirection, 1, legRA, c_white, 1);
    
// Right leg
draw_sprite_ext(m_legSprite, 0, legLX, legLY + legRYOff, 
    m_imageDirection, 1, legLA, c_white, 1);

// Draw the body
draw_sprite_ext(m_headSprite, 0, x, y + m_bodyOffsetY,
    m_imageDirection, 1, m_bodyAngle, c_white, 1);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the bow

// Calculate string positions
var x1, y1, x2, y2, x3, y3;
var height = sprite_get_height(m_spriteBow) / 2 - m_stringPixelOffset;

x1 = m_bowX + lengthdir_x(height , m_bowAngle - 90);
y1 = m_bowY + lengthdir_y(height , m_bowAngle - 90);

x2 = m_bowX + lengthdir_x(height , m_bowAngle + 90);
y2 = m_bowY + lengthdir_y(height , m_bowAngle + 90);

x3 = m_bowX + lengthdir_x(m_stringDistance, m_bowAngle + 180);
y3 = m_bowY + lengthdir_y(m_stringDistance, m_bowAngle + 180);

// Draw the string
draw_set_color(c_white);

middle = draw_bezier(x1, y1, x3, y3, x2, y2);

// Draw the bow sprite
draw_sprite_ext(m_spriteBow, 0, m_bowX, m_bowY, 1, 1, m_bowAngle, c_white, 1);

// Draw a 'fake' arrow, but only if the arrow isn't shot
if(m_arrowActive)
{
    var x1, y1, x2, y2;
    x1 = middle[0]
    y1 = middle[1]
    
    x2 = x1 + lengthdir_x(ARROW_LENGTH, m_bowAngle)
    y2 = y1 + lengthdir_y(ARROW_LENGTH, m_bowAngle)
    
    draw_line_width(x1, y1, x2, y2, ARROW_WIDTH);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the hat

var ypos;

if(m_vsp &gt; 0) { ypos = yprevious; }
else { ypos = y; }

var xdir = m_imageDirection;

// Calculate the vertical offset
hatBX = x + lengthdir_x(m_hatHeight - m_bodyOffsetY, m_bodyAngle + 90);
hatBY = ypos + lengthdir_y(m_hatHeight - m_bodyOffsetY, m_bodyAngle + 90);

// Add the horizontal offset
var val = 0;
if(xdir == 1) { val = 180; }

hatX = hatBX + lengthdir_x(8, m_bodyAngle - val);
hatY = hatBY + lengthdir_y(8, m_bodyAngle - val);

draw_sprite_ext(m_spriteHat, 0, hatX, hatY,
xdir, 1, (12 * xdir) + m_bodyAngle, c_white, 1);

//draw_sprite_ext(m_spriteHat, 0, x - (8 * xdir), ypos - m_hatHeight + m_bodyOffsetY,
//xdir, 1, (12 * xdir) + m_bodyAngle, c_white, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
