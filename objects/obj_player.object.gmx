<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign 'prevs'
m_lerpStickPrev = m_lerpedStick;
m_keyJumpPrev = (m_rTrigger &gt; m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get the player's input

// Controller

m_lStickH = gamepad_axis_value(m_controllerId, gp_axislh);
m_lStickV = gamepad_axis_value(m_controllerId, gp_axislv);

m_rStickH = gamepad_axis_value(m_controllerId, gp_axisrh);
m_rStickV = gamepad_axis_value(m_controllerId, gp_axisrv);

m_lTrigger = gamepad_button_check(m_controllerId, gp_shoulderlb);
m_rTrigger = gamepad_button_check(m_controllerId, gp_shoulderrb);

m_buttonA = gamepad_button_check(m_controllerId, gp_face1);
m_buttonB = gamepad_button_check(m_controllerId, gp_face2);
m_buttonX = gamepad_button_check(m_controllerId, gp_face3);
m_buttonY = gamepad_button_check(m_controllerId, gp_face4);

m_buttonAPressed = gamepad_button_check_pressed(m_controllerId, gp_face1);
m_buttonBPressed = gamepad_button_check_pressed(m_controllerId, gp_face2);
m_buttonXPressed = gamepad_button_check_pressed(m_controllerId, gp_face3);
m_buttonYPressed = gamepad_button_check_pressed(m_controllerId, gp_face4);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign buttons

m_keyJump = (m_rTrigger &gt; m_controllerDeadzone &amp;&amp; !m_keyJumpPrev);
m_keyJumpHeld = (m_rTrigger &gt; m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEBUG KEYBOARD INPUT
if (m_playerId == 0)
{
   if(!gamepad_is_connected(0))
   {
      m_lStickH = (-keyboard_check(vk_left) + keyboard_check(vk_right))
      m_keyJump = keyboard_check_pressed(vk_up);
      m_keyJumpHeld = keyboard_check(vk_up);
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update playerstates

// On the ground
if (place_meeting(x,y+1,obj_collider)) 
{
    if(!m_onGround)
    {
        // Set squishy landing
        m_imageXScale = 1.4;
        m_imageYScale = 0.7;
    }
    
    m_onGround = true;
}
else 
{
    m_onGround = false;
    
    // Against a wall
   if ((place_meeting(x - 3,y, obj_collider)) || (place_meeting(x + 3,y, obj_collider)))
   {
      if (m_againstWall == false)
      { 
         m_jumps = 1; 
      }
      
     m_againstWall = true;
     m_wallDir = (-(place_meeting(x - m_wallDistance,y,obj_collider)) + (place_meeting(x + m_wallDistance,y,obj_collider)));
   }
   else 
   {
      m_againstWall = false;
      m_wallDir = 0;
   }
}

if (abs(m_lStickH) &lt; m_dashDanceMargin )
{
   m_dashDanceActive = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Calculate accelleration
//* and control speed in mid-air

var stick = m_lStickH
var inertia = 0;

if (m_onGround) // On the ground
{
    inertia = m_inertiaGround;
}

else // InAir
{ 
    inertia = m_inertiaAir;
}

m_lerpedStick = lerp(m_lerpedStick, stick, inertia);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move to inputs

move = m_lerpedStick;
m_hsp = move * m_movespeed;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control gravity
if (m_againstWall)
{
   if (m_vsp &lt; m_maxFallSpeed / 4)
   {
      m_vsp += m_grav
   }
}
else
{
   if (m_vsp &lt; m_maxFallSpeed) 
   { 
       m_vsp += m_grav; 
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Jumping

if (m_onGround) // If the player is on the ground
{
   m_jumps = m_jumpsmax; // Reset the jump amount
}
else // Player is in the air
{
   if (m_jumps == m_jumpsmax) { m_jumps -=1; } // If jumps is equal to the max, subtract one
}

if ((m_keyJump) &amp;&amp; (m_jumps &gt; 0))
{
   m_jumps -= 1;
   m_vsp = -m_jumpspeed;
    
   if(m_jumps == 0) // Activate air-dash
   {
      m_hspFinal = 0;
      m_hsp = 0;
    
      m_playerState = m_playerStates.airDashing
      m_lerpedStick = (m_lStickH * m_airDashSpeed) * 0.7;
      
      if (m_againstWall)
      {
         m_lerpedStick -= m_wallDir;
         m_vsp = -m_jumpspeed * 1.2;
      }
      
      effect_create_below(ef_smoke, x, y + 16, 1, c_gray);
   }
   
   // Set squishy jump
   m_imageXScale = 0.6;
   m_imageYScale = 1.3;
}

if ((m_vsp &lt; 0) &amp;&amp; (!m_keyJumpHeld)) { 
    m_vsp = max(m_vsp, -m_jumpspeed / 3);  
}


m_hspFinal = m_hsp + m_hspCarry;
m_hspCarry = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control Dash Dance

if (m_onGround) // Check if the player is on the ground
{  
   if (m_dashDanceTimer &gt; 0) // Check if the timer is larger than 0
   {
      if(m_lStickH * -m_dashDancePrev &gt; m_dashDanceMargin) // Check if the current input is the same as the previous * -0.9
      {
         m_lerpedStick = sign(m_lStickH); // Apply the new velocity multiplier
      }
   
      m_dashDanceTimer--; // Time the timer
   }
   
   if (abs(m_lerpedStick) &gt; m_dashDanceMargin &amp;&amp; !m_dashDanceActive) // Check if the velocity multiplier is higher then 0.9
   {
      m_dashDanceTimer = m_dashDanceWindow; // Set the timer
      m_dashDancePrev = sign(m_lStickH); // Set the old position of the stick to the current
      
      m_dashDanceActive = true;
   }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Collision
if (place_meeting(x+m_hspFinal,y,obj_collider))
{
    while(!place_meeting(x+sign(m_hspFinal), y, obj_collider))
    {
        x += sign(m_hspFinal);
    }
    
    m_hspFinal = 0;
    m_hsp = 0;
    m_lerpedStick = 0;
}

x += m_hspFinal;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical Collision
if (place_meeting(x,y+m_vsp,obj_collider))
{
    while(!place_meeting(x, y+sign(m_vsp), obj_collider))
    {
        y += sign(m_vsp);
    }
    m_vsp = 0;
}

y += m_vsp;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control bow

// Check if active
var largStick = max(abs(m_rStickH), abs(m_rStickV))
var trigger = m_rTrigger;
var arrowForce;

if(largStick &gt; 0.8)
{ m_bowActive = true; }
else { m_bowActive = false; }

// Calculate bow's angle
if(largStick &gt; 0.25)
{ m_bowAngle = point_direction(0, 0, m_rStickH, m_rStickV); }


// Calculate distance
var distance = 16;
if(m_bowActive) { distance = 32; }

m_bowDistance = lerp(m_bowDistance, distance, 0.3);

// Position the bow
var yOffset = sprite_get_height(sprite_index) / 2;
m_bowX = x + lengthdir_x(m_bowDistance, m_bowAngle);
m_bowY = (y - yOffset) + lengthdir_y(m_bowDistance, m_bowAngle);

// Control shooting

// Animate the string

if((m_bowActive &amp;&amp; (m_bowCharge &gt;= m_bowFireRate)) || !m_bowActive)// remove bowcharge
{
    m_stringDistance = ease_out_elastic(m_stringTimer, ARROW_LENGTH, -ARROW_LENGTH, 
                                        m_stringAnimTime);
    
    // time the timer
    if(m_stringTimer &lt; m_stringAnimTime)
    { m_stringTimer++; }
}
else if(m_bowActive)
{ 
    m_stringTimer = 0;
    m_stringDistance = lerp(m_stringDistance, ARROW_LENGTH, 0.3); 
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animate

// Lerp scale for squishyness
m_imageXScale = lerp(m_imageXScale, 1, 0.2);
m_imageYScale = lerp(m_imageYScale, 1, 0.2);

signMove = sign(move);

if (m_lStickH != 0 &amp;&amp; (m_onGround || m_againstWall)) { m_imageDirection = signMove; }
   
if (place_meeting(x,y+1,obj_collider)) // Player is on the ground
{
    if (abs(move) &gt; 0.5) 
    {
        m_spriteIndex = m_spriteRun; 
        m_imageSpeed = 0.25;
    }
    else 
    {
        m_spriteIndex = m_spriteIdle; 
        m_imageSpeed = 0.25;
    }
}
else // Player is in the air
{
     if (m_againstWall) { m_spriteIndex = m_spriteWallSlide }
     else if (m_vsp &lt; 0) { m_spriteIndex = m_spriteJump; } 
     else { m_spriteIndex = m_spriteFall; }
}

if (!m_onGround)
{
    m_imageAngle = (25 * (move * -1));
}
else
{
    // Calcutate angle
    angle_next = 0  // The angle where we need to go to
    angle_prev = m_imageAngle; // the last angle of the image
    angle_diff = angle_difference(angle_prev,angle_next); // get the difference between the angle
    
    angle_next = angle_prev-angle_diff; // convert the angle to a number outside of 0-360 if needed
    
    m_imageAngle = lerp(m_imageAngle, angle_next, 0.6);
}

// Time the animation
m_imageIndex += m_imageSpeed;

if(m_imageIndex &gt; sprite_get_number(m_spriteIndex))
{
    m_imageIndex = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Create" event</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize variables

m_grav = 0.8;

// Player's states
m_playerState = m_playerStates.normal;

m_onGround = false;
m_againstWall = false;

enum m_playerStates 
{
    normal,
    airDashing
}


// Movement
m_hsp = 0;
m_hspCarry = 0;
m_hspFinal = 0;

m_accelation = 0;           // This value lerps to 1 if waling anf to 0 if staning still
m_accelationAmount = 0.1;   // The lerp interpolation for acceleration

m_vsp = 0;
m_movespeed = 12;
m_moveDir = 0;

m_inertiaGround = 0.2;
m_inertiaAir = 0.07;
m_inertiaDash = 0.02;

m_lerpedStick = 0;

// Jumping
m_jumps = 0;
m_jumpsmax = 2;
m_jumpspeed = 18;
m_maxFallSpeed = 30;

m_airDashSpeed = 2.2;   // lerpStick gets multiplied with this value

// Dash dancing
m_dashDanceWindow = 20;
m_dashDanceTimer = 0;
m_dashDancePrev = 0;
m_dashDanceActive = false;
m_dashDanceMargin = 0.9;


// Wallclinging
m_wallDir = 0;       // The direction of the wall the player is clinging to (either -1 or 1)
m_wallDistance = 3;  // The distance for the player to cling to a wall

// Bow
m_bowActive = false;
m_bowAngle = 0;
m_bowCharge = 0;
m_bowFireRate = 10;
m_bowDistance = 0;
m_bowX = x;
m_bowY = y;
m_triggerPrev = 0;
m_bowDeltaMax = 3
m_bowDeltaTimer = 0;
m_bowDeltaThreshold = 0.3;

m_stringDistance = 0;
m_stringPixelOffset = 2;
m_stringAnimTime = 30;
m_stringTimer = 0;


// Keys
m_keyJump = false;
m_keyJumpPrev = false;
m_keyJumpHeld = false;

// Sprites
m_spriteIndex = 0;

m_spriteIdle = noone;
m_spriteJump = noone;
m_spriteFall = noone;
m_spriteWalk = noone;
m_spriteRun = noone;

m_imageIndex = 0;
m_imageSpeed = 1;
m_imageXScale = 1;
m_imageYScale = 1;
m_imageAngle = 0;
m_imageBlend = c_white;
n_imageAlpha = 1;

m_imageDirection = 1;

// Controller
m_controllerId = 0;
m_controllerDeadzone = 0.3;

m_lStickH = 0;
m_lStickV = 0;

m_rStickH = 0;
m_rStickV = 0;

m_lTrigger = 0;
m_rTrigger = 0;

m_buttonA = false;
m_buttonB = false;
m_buttonX = false;
m_buttonY = false;

m_buttonAPressed = false;
m_buttonBPressed = false;
m_buttonXPressed = false;
m_buttonYPressed = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize player
m_controllerId = m_playerId;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize controller

// Set the deadzone
gamepad_set_axis_deadzone(m_controllerId, m_controllerDeadzone);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Assign character specific values

m_spriteIdle = spr_p1_idle;
m_spriteJump = spr_p1_jump;
m_spriteFall = spr_p1_fall;
m_spriteRun = spr_p1_walking;
m_spriteWallSlide = spr_p1_wall;

m_spriteBow = spr_bow;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw debug info
if (m_playerId != 0)
   exit;

draw_text_debug(0, "lStick: h " + string(m_lStickH));
draw_text_debug(1, "lerpstick: " + string(m_lerpedStick));
draw_text_debug(2, "jumpStick: " + string(m_rTrigger));
draw_text_debug(3, "hsp: " + string(m_hsp));
draw_text_debug(4, "vsp: " + string(m_vsp));
draw_text_debug(5, "playerstate: " + string(m_playerState));
draw_text_debug(6, "angle: " + string(m_imageAngle));
draw_text_debug(7, "against wall: " + string(m_againstWall));
draw_text_debug(8, "DDance timer: " + string(m_dashDanceTimer));
draw_text_debug(9, "DDance prev: " + string(m_dashDancePrev));
draw_text_debug(10, "Arrow count: " + string(instance_number(obj_arrow)));
draw_text_debug(11, "rStick h: " + string(m_rStickH));
draw_text_debug(12, "rStick v: " + string(m_rStickV));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player
var spriteHeight  = sprite_get_height(m_spriteIndex);

var color = make_colour_hsv(m_playerId * 30, 255, 255);

draw_sprite_ext(m_spriteIndex, m_imageIndex, x, y, // + (spriteHeight / 2)
m_imageXScale * m_imageDirection, m_imageYScale, m_imageAngle, c_white, n_imageAlpha);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the bow

// Calculate string positions
var x1, y1, x2, y2, x3, y3;
var height = sprite_get_height(m_spriteBow) / 2 - m_stringPixelOffset;

x1 = m_bowX + lengthdir_x(height , m_bowAngle - 90);
y1 = m_bowY + lengthdir_y(height , m_bowAngle - 90);

x2 = m_bowX + lengthdir_x(height , m_bowAngle + 90);
y2 = m_bowY + lengthdir_y(height , m_bowAngle + 90);

x3 = m_bowX + lengthdir_x(m_stringDistance, m_bowAngle + 180);
y3 = m_bowY + lengthdir_y(m_stringDistance, m_bowAngle + 180);

// Draw the string
draw_set_color(c_white);

middle = draw_bezier(x1, y1, x3, y3, x2, y2);

// Draw the bow sprite
draw_sprite_ext(m_spriteBow, 0, m_bowX, m_bowY, 1, 1, m_bowAngle, c_white, 1);

// Draw a 'fake' arrow, but only if the arrow isn't shot
if(m_bowActive &amp;&amp; (m_bowCharge &lt;= m_bowFireRate))
{
    var x1, y1, x2, y2;
    x1 = middle[0]
    y1 = middle[1]
    
    x2 = x1 + lengthdir_x(ARROW_LENGTH, m_bowAngle)
    y2 = y1 + lengthdir_y(ARROW_LENGTH, m_bowAngle)
    
    draw_line_width(x1, y1, x2, y2, ARROW_WIDTH);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(x, y - 32, m_playerId);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
