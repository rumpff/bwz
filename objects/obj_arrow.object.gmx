<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_arrowMask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Do da drew angla

m_drawAngle = point_direction(0, 0, m_moveX, m_moveY);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update movement
if(!m_wallHit &amp;&amp; (m_arrowType != 3))
{
    m_moveY += (global.grav * global.timeScale);
    
    image_angle = point_direction(x, y, x + m_moveX, y + m_moveY);
    
    if (place_meeting(x + (m_moveX * global.timeScale), y + (m_moveY * global.timeScale), obj_collider))
    {
        var verticalSpeed = (m_moveY * global.timeScale);
        for (i = 0; i &lt; abs(verticalSpeed); i++)
        {
            if (!place_meeting(x, y + sign(verticalSpeed), obj_collider))
            {
                y += sign(verticalSpeed);
            } else break;
        };
        
        var horizontalSpeed = (m_moveX * global.timeScale);
        for (i = 0; i &lt; abs(horizontalSpeed); i++)
        {
            if (!place_meeting(x + sign(horizontalSpeed), y, obj_collider))
            {
                x += sign(horizontalSpeed);
            } else break;
        };
        
        m_wallHit = true;
        m_wiggle = m_wiggleMax;
    }
    else
    {
        x += (m_moveX * global.timeScale);
        y += (m_moveY * global.timeScale);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for collision with the player

if(!m_wallHit)
{   
    var playerAmount = array_length_1d(obj_gameManager.m_playerArray);
    
    for (i=0; i&lt;playerAmount; i+=1)
    {
        var playerObject = obj_gameManager.m_playerArray[i];
                    
        //if (collision_line(x, y, xprevious, yprevious, playerObject, false, false))
        if(place_meeting(x, y, playerObject))
        {      
            if(playerObject.m_playerId == m_id &amp;&amp; m_initialCooldown &gt; 0)
            { } // Prevent player from walking in its own arrow
            else
            { death(playerObject, m_id, id); } // Kill that sucker
        }
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Warp room borders

if(m_warped &lt; 2)
{
    if (x &lt; 0)
        { x += room_width; m_warped++; } 
    if (x &gt; room_width)
        { x -= room_width; m_warped++; }
    if (y &lt; 0)
        { y += room_height; m_warped++; }
    if (y &gt; room_height)
        { y -= room_height; m_warped++; }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Type 3 (bounce)

if(!m_wallHit &amp;&amp; m_arrowType == 3)
{
    m_moveY += (global.grav * global.timeScale);
    
    image_angle = point_direction(x, y, x + m_moveX, y + m_moveY);
    
    if (place_meeting(x + (m_moveX * global.timeScale), y + (m_moveY * global.timeScale), obj_collider))
    {
        var horizontalSpeed = (m_moveX * global.timeScale);
        for (i = 0; i &lt; abs(horizontalSpeed); i++)
        {
            if (!place_meeting(x + sign(horizontalSpeed), y, obj_collider))
            {
                x += sign(horizontalSpeed);
            } else { m_moveX *= -1; break; }
        };
        
        var verticalSpeed = (m_moveY * global.timeScale);
        for (i = 0; i &lt; abs(verticalSpeed); i++)
        {
            if (!place_meeting(x, y + sign(verticalSpeed), obj_collider))
            {
                y += sign(verticalSpeed);
            } else { m_moveY *= -1; break; }
        };
        
        m_bounces--; 
    }
    else
    {
        x += (m_moveX * global.timeScale);
        y += (m_moveY * global.timeScale);
    }
}

if(m_bounces &lt; 0)
{
    m_arrowType = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Type 4 (explosion)

if(m_arrowType = 4 &amp;&amp; m_wallHit)
{
    var explosion = instance_create(x, y, obj_explosion);
    explosion.m_id = m_id;
    with(explosion) { event_user(0); }
    
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Type 5 (teleport)

if(m_arrowType = 5 &amp;&amp; !m_hasTeleported &amp;&amp; m_wallHit)
{
    var player = obj_gameManager.m_playerArray[m_id];
    
    if(instance_exists(player))
    {
        var xpos = x;
        var ypos = y;
        var dist = 0;
        var collision = true;
        
        while(collision)
        {
            for(i = 0; i &lt; 8; i++)
            {
                var xnew = xpos + lengthdir_x(dist, i * (360 / 8));
                var ynew = ypos + lengthdir_y(dist, i * (360 / 8));
                
                if(!collision_rectangle(xnew-24, ynew-24, xnew+24, ynew+24, obj_collider, false, false))
                {
                    xpos = xnew;
                    ypos = ynew;
                    collision = false;
                    break;
                }
            }
            
            dist++;
        }        
        
        
        var effec1 = instance_create(player.x, player.y, obj_teleportEffect);
        effec1.m_type = 0;
        with(effec1) { event_user(0); }
        
        var effec2 = instance_create(xpos, ypos, obj_teleportEffect);
        effec2.m_type = 1;
        with(effec2) { event_user(0); }
        
        player.x = xpos;
        player.y = ypos
        
        play_sound(snd_teleport);
    }
    
    m_hasTeleported = true;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Timers

if(m_initialCooldown &gt; 0)
{ m_initialCooldown -= global.timeScale; }

if((m_wallHit) &amp;&amp; m_wiggle &gt; 0)
{ m_wiggle--; }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Create event"</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize variables

//m_angle;
//m_force;
//m_id;
//m_arrowType;

m_moveSpeed = ARROW_SPEED * m_force;
m_length = ARROW_LENGTH;
m_wallHit = false;
m_drawAngle = m_angle;
m_wiggle = 0;
m_wiggleMax = 20;
m_warped = 0;

m_initialCooldown = 2; // Gives the player who shot the arrow x frames of invincibility for that this arrow
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Type Specials

// type 3 (bounce)
m_bounces = 2;

// type 5 (teleport)
m_hasTeleported = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// calculate movement speeds and such

m_moveX = lengthdir_x(m_moveSpeed, m_angle);
m_moveY = lengthdir_y(m_moveSpeed, m_angle);

image_xscale = m_moveSpeed / 100;
image_yscale = m_moveSpeed / 100;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the arrow

draw_set_color(c_white);

var wiggleoff = 0; 
//if(m_wallHit) { wiggleoff = ease_out_elastic(m_wiggle, m_wiggleMax, -m_wiggleMax, m_wiggleMax); }

var x2 = x + lengthdir_x(m_length, m_drawAngle+wiggleoff);
var y2 = y + lengthdir_y(m_length, m_drawAngle+wiggleoff);

draw_line_width(x, y, x2, y2, ARROW_WIDTH);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
