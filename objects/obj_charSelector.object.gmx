<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get input
// Up
if (gamepad_axis_value(m_controllerId, gp_axislv) &lt; -m_gpDeadzone)
{
    m_inputUp = input_timers_active(0);
}
else
{   
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padu))
    {
        m_inputUp = true;
    }
    else
    {
        // Reset all timer values
        m_inputUp = input_timers_reset(0);
    }
}

// Down
if (gamepad_axis_value(m_controllerId, gp_axislv) &gt; m_gpDeadzone)
{
    m_inputDown = input_timers_active(1);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padd))
    {
        m_inputDown = true;
    }
    else
    {
        // Reset all timer values
        m_inputDown = input_timers_reset(0);
    }
}

// Left
if (gamepad_axis_value(m_controllerId, gp_axislh) &lt; -m_gpDeadzone)
{
    m_inputLeft = input_timers_active(2);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padl))
    {
        m_inputLeft = true;
    }
    else
    {
        // Reset all timer values
        m_inputLeft = input_timers_reset(0);
    }
}

// Right
if (gamepad_axis_value(m_controllerId, gp_axislh) &gt; m_gpDeadzone)
{
    m_inputRight = input_timers_active(3);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padr))
    {
        m_inputRight = true;
    }
    else
    {
        // Reset all timer values
        m_inputRight = input_timers_reset(0);
    }
}

// Buttons
m_inputSelect = gamepad_button_check_pressed(m_controllerId, gp_face1);
m_inputShift = gamepad_button_check(m_controllerId, gp_shoulderrb);
m_inputBack = gamepad_button_check_pressed(m_controllerId, gp_face2);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get input keyboar

if(m_id == 0)
{
    // Up
    m_inputUp = keyboard_check_pressed(vk_up);
    
    // Down
    m_inputDown = keyboard_check_pressed(vk_down);
    
    // Left
    m_inputLeft = keyboard_check_pressed(vk_left);
    
    // Right
    
    m_inputRight = keyboard_check_pressed(vk_right);
    
    // Buttons
    m_inputSelect = keyboard_check_pressed(vk_enter);
    m_inputShift = keyboard_check(vk_lshift);
    m_inputBack = keyboard_check_pressed(vk_escape);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// BoxUpdate

// Lerp the size
m_drawWidth = lerp(m_drawWidth, m_contWidth, 0.2) + (cos(m_containterSin) * 2);
m_drawHeight = lerp(m_drawHeight, m_contHeight, 0.2) + (sin(m_containterSin) * 2);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Do tings for all states

if((m_inputBack) &amp;&amp; (m_currentState &gt; 0))
{
    m_currentState--;
}

m_sinCounter += 0.03;
m_containterSin -= 0.07;

if(m_currentState == 3)
{
    m_ready = true;
}
else
{
    m_ready = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 3

if(m_currentState == 3)
{   
    var w = m_drawWidth;
    var h = m_drawHeight;
    
    // set the container to the right size   
    m_contWidth = 250;
    m_contHeight = 125;
    
    global.playerSprite[m_id] = m_currentPlayer;
    global.playerHat[m_id] = m_currentHat;
    global.playerColor[m_id] = make_color_hsv(m_currentColor, 255, 255);
    global.playerName[m_id] = m_name;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 2

if(m_currentState == 2)
{   
    var w = m_drawWidth;
    var h = m_drawHeight;
    
    // set the container to the right size   
    m_contHeight = 750;
    
    if(m_drawHeight &gt; 740)
    {
        m_contWidth = 350; 
    }
    
    // Lerp the selector pos
    switch(m_charCurrent)
    {
        case 0:
            m_charSelectPos = lerp(m_charSelectPos, y - (h/4), 1);
            m_charSelectNormal = true;
            break;
            
        case 1:
            m_charSelectPos = lerp(m_charSelectPos, y, 1);
            m_charSelectNormal = true;
            break;
        
        case 2:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/4), 1);
            m_charSelectNormal = true;
            break;
        case 3:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/2.5), 1);
            m_charSelectNormal = false;
            break;
    }
    
    m_charSLOffset = lerp(m_charSLOffset, 0, 0.2);
    m_charSROffset = lerp(m_charSROffset, 0, 0.2);
    
    // Set the ready text
    if(m_charCurrent == 3)
    {  m_readyText = "READY?"; }
    else { m_readyText = "READY"; }
    
    // Check the inputs
    
    if(m_inputSelect)
    {
        if(m_charCurrent == 3)
        {
            m_currentState++;
        }
        else
        {
            m_charCurrent = 3;
        }
    }
    
    if (m_inputUp)
    {
        if(m_charCurrent &gt; 0)
        { m_charCurrent--; audio_play_sound(snd_cursorMove, 1, 0); }
    }
    
    if (m_inputDown)
    {
        if(m_charCurrent &lt; 3)
        { m_charCurrent++; audio_play_sound(snd_cursorMove, 1, 0); }
    }
    
    if (m_inputLeft)
    {
        var valid = false;
        
        switch(m_charCurrent)
        {
            case 0:
                if(m_currentColor &lt;= 0)
                { m_currentColor = 255; }
                
                m_currentColor -= 17;
                valid = true;
                break;
                
            case 1:
                if (m_currentHat &gt; 0) 
                { m_currentHat--; valid = true;}
                break;
                
            case 2:
                if (m_currentPlayer &gt; 0) 
                { m_currentPlayer--; valid = true;}
                break;
        }
        
        if(valid)
        { m_charSLOffset = 16; audio_play_sound(snd_sweep, 1, 0); }
    }
    
    if (m_inputRight)
    {
        var valid = false;
        
        switch(m_charCurrent)
        {
            case 0:
                if(m_currentColor &gt;= 255)
                { m_currentColor = 0; }
                
                m_currentColor += 17;
                valid = true;
                break;
                
            case 1:
                if (m_currentHat &lt; (sprite_get_number(spr_hats) - 1)) 
                { m_currentHat++; valid = true;}
                break;
                
            case 2:
                if (m_currentPlayer &lt; (sprite_get_number(spr_players) - 1)) 
                { m_currentPlayer++; valid = true;}
                break;
        }
        
        if (valid)
        { m_charSROffset = 16; audio_play_sound(snd_sweep, 1, 0); }
    }
    
    
    // Set selector cordinates
    if(m_charSelectNormal)
    {
        var lerpVal = 0.33;
        
        // Left up
        m_LUX1 = lerp(m_LUX1, x - 128 - m_charSLOffset, lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos, lerpVal);
        m_LUX2 = lerp(m_LUX2, x - 96 - m_charSLOffset, lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos - 32, lerpVal);
        
        // Left bottom    
        m_LBX1 = lerp(m_LBX1, x - 128 - m_charSLOffset, lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos, lerpVal);
        m_LBX2 = lerp(m_LBX2, x - 96 - m_charSLOffset, lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + 32, lerpVal);
    
        // Right up
        m_RUX1 = lerp(m_RUX1, x + 128 + m_charSROffset, lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos, lerpVal);
        m_RUX2 = lerp(m_RUX2, x + 96 + m_charSROffset, lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos - 32, lerpVal);
        
        // Right bottom      
        m_RBX1 = lerp(m_RBX1, x + 128 + m_charSROffset, lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos, lerpVal);
        m_RBX2 = lerp(m_RBX2, x + 96 + m_charSROffset, lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + 32, lerpVal);
    }
    else // Selector is on ready
    {
        var lerpVal = 0.33;
        var tWidth = string_width(m_readyText) + 16;
        var tHeight = string_height(m_readyText) + 2;
        
        // Up
        m_LUX1 = lerp(m_LUX1, x - (tWidth/2) - 1, lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos - (tHeight/2), lerpVal);
        m_LUX2 = lerp(m_LUX2, x + (tWidth/2), lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos - (tHeight/2), lerpVal);
        
        // Left    
        m_LBX1 = lerp(m_LBX1, x - (tWidth/2), lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos - (tHeight/2), lerpVal);
        m_LBX2 = lerp(m_LBX2, x - (tWidth/2), lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + (tHeight/2), lerpVal);
    
        // Right
        m_RUX2 = lerp(m_RUX2, x + (tWidth/2), lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos - (tHeight/2), lerpVal);
        m_RUX1 = lerp(m_RUX1, x + (tWidth/2), lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos + (tHeight/2), lerpVal);
        
        // Bottom 
        m_RBX1 = lerp(m_RBX1, x + (tWidth/2), lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos + (tHeight/2), lerpVal);
        m_RBX2 = lerp(m_RBX2,  x - (tWidth/2), lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + (tHeight/2), lerpVal);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 1

if(m_currentState == 1)
{
    // Set, depending on the size of the name and if shift is helf, the letters in uppercase or lowercase
    if((string_length(m_name) == 0 &amp;&amp; !m_inputShift) || (m_inputShift &amp;&amp; string_length(m_name) != 0)) 
    { m_alphabet = string_upper(m_alphabet) }
    else { m_alphabet = string_lower(m_alphabet) }
    
    // set the container to the right size
    m_contHeight = 600;    
    if(m_drawHeight &gt; 590)
    {
        m_contWidth = 300; 
    }
    
    // Animate selecor
    m_selectorDist = lerp(m_selectorDist, m_selectorMaxDistance, 0.17);
    m_selectorAngleOff = lerp(m_selectorAngleOff, 0, 0.17);
    
    // Set all the positions for the letters
    m_letterBoxX[0] = 0;
    m_letterBoxY[0] = 0;  
    
    
    var sx = x - m_drawWidth/2;
    var sy = y - m_drawHeight/6;
    
    var boxIndex = 0;
    
    var bwidth = m_drawWidth / m_xRows;
    var bheight = m_drawHeight / m_yRows;
    
    for (iy = 0; iy &lt; 8; iy++)
    {
        for (ix = 0; ix &lt; 4; ix++)
        {
            if(boxIndex &lt; string_length(m_alphabet))
            {
                m_letterBoxX[boxIndex] = sx + (ix * bwidth); // left x
                m_letterBoxY[boxIndex] = sy + (iy * bheight * 0.66); // upper y
                
                boxIndex++;
            }
        }    
    }
    
    // Scale the letters
    for (i = 0; i &lt; array_length_1d(m_letterBoxX); i++)
    {
        if ((array_length_1d(m_letterRot) - 1) &lt; i)
        { m_letterRot[i] = 0; m_letterSat[i] = 0; }
        else
        { m_letterRot[i] = lerp(m_letterRot[i], 0, 0.1); 
        m_letterSat[i] = lerp(m_letterSat[i], 0, 0.2); }
        
    }
    
    
    // Get input from the selection
    if(m_inputSelect)
    {
        var newLetter = string_copy(m_alphabet, m_selectorPos+1, 1);
        var nameLength = string_length(m_name);
        m_letterRot[m_selectorPos] = choose(-30, 30);
        m_letterSat[m_selectorPos] = 255;
        m_selectorDist = m_clickDistance;
        
        switch(newLetter)
        {
            case "&lt;":
                // Remove a letter   
                m_name = string_delete(m_name, nameLength, 1);
                audio_play_sound(snd_letterRemove, 1, 0);
                m_selectorAngleOff = -90;
                break;
                
            case "&gt;":
                // Goto next state
                if(nameLength &gt; 0) // name isn't empty
                {
                    m_currentState++;
                }
                break;
                
            default:
                // Add the letter
                if(nameLength &lt; m_maxNameLength)
                { 
                    m_name += newLetter;
                    var snd = audio_play_sound(snd_letterEnter, 1, 0);
                    audio_sound_pitch(snd, random_range(.9, 1.1));
                }
                else
                {
                    // name at limit
                }
                
                if (nameLength == m_maxNameLength) // Move the cursor to confirm if the max length is reached
                {
                    m_selectorPos = array_length_1d(m_letterBoxX)-1;
                    audio_play_sound(snd_letterFull, 1, 0);
                }
                
                m_selectorAngleOff = 90;
                break;
        }
    }
    
    // Move the selection
    var moved = false;
    
    if(m_inputUp &amp;&amp; (m_selectorPos - m_xRows) &gt;= 0)
    {
        m_selectorPos -= m_xRows;
        moved = true;
    }
    if(m_inputDown &amp;&amp; (m_selectorPos + m_xRows) &lt; array_length_1d(m_letterBoxX))
    {
        m_selectorPos += m_xRows;
        moved = true;
    }
    
    if(m_inputLeft &amp;&amp; ((m_selectorPos-1+m_xRows) mod m_xRows) != m_xRows-1)
    {
        m_selectorPos--;
        moved = true;
    }
    if(m_inputRight &amp;&amp; ((m_selectorPos+1+m_xRows) mod m_xRows) != 0 &amp;&amp; m_selectorPos+1 &lt; array_length_1d(m_letterBoxX))
    {
        m_selectorPos++;
        moved = true;
    }
    
    if(moved) 
    { 
        m_selectorDist =  (m_selectorMaxDistance * .8); 
        audio_play_sound(snd_cursorMove, 1, 0);
    }
    
    // Set the selector's position
    m_selectorX = lerp(m_selectorX, m_letterBoxX[m_selectorPos] + (bwidth / 2), 0.4);
    m_selectorY = lerp(m_selectorY, m_letterBoxY[m_selectorPos] + (bheight / 2), 0.4);
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 0

if(m_currentState == 0)
{
    // set the box to the right size
    m_contHeight = 100;
    m_contWidth = 400;
    
    // Check for input
    if (m_inputSelect)
    { m_currentState++; } // Go to the next state
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Create Event"</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize variables

enum m_selectStates // The states where the box can be in
{
    PressA, // 0
    EnterName, // 1
    SelectCharacter, // 2
    Ready // 3
}


m_currentState = 0; // The current state of the box
m_ready = false;
//m_totalAmount = noone; // The total amount of this object, used for positioning

m_drawWidth = 0; // The current width of the container
m_drawHeight = 0; // The current height of the container

m_contWidth = 0; // The width where the box lerps to
m_contHeight = 0; // The height where the box lerps to

m_sinCounter = 0; // Value for sinus effects
m_containterSin = (m_id / 4);

/// Input
m_controllerId = m_id; // Which controller controlls this selector
m_gpDeadzone = 0.3;

m_inputUp = false;
m_inputDown = false;
m_inputLeft = false;
m_inputRight = false;
m_inputSelect = false;
m_inputBack = false;

m_inputTimerMax = 22;
m_inputTimerMin = 10;

for (i = 0; i &lt; 4; i++) // 0 = up, 1 = down, 2 = left, 3 = right
{
    m_inputTimer[i] = 0;
    m_inputTimerCurrent[i] = m_inputTimerMax;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set position

y = room_height / 2;
x = room_width / 4 * (m_controllerId+1) - room_width / 8;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State 1 specifics

var b2b = sqrt(sqr(16) * 2); // Selector's with to exact touch borders

m_selectorMaxDistance = b2b * 1.5;
m_clickDistance = b2b / 1.5;

m_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;&gt;";

m_letterBoxX[0] = 0;
m_letterBoxY[0] = 0;
m_letterRot[0] = 0;
m_letterSat[0] = 0;

m_xRows = 4;
m_yRows = 8;

m_selectorPos = 0;
m_selectorX = x;
m_selectorY = y;
m_selectorDist = 0;
m_selectorAngleOff = 0;

m_name = ""; // The name that the player enters
m_maxNameLength = 5;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State 2 specifics

m_currentPlayer = 0;
m_currentHat = 0;
m_currentColor = 0;

m_charCurrent = 2;
m_charSelectPos = y;
m_charSelectNormal = true;

m_readyText = "READY"

// Offset from the selectors xpos
m_charSLOffset = 0;
m_charSROffset = 0;

// Coordinates for the selector lines

// Left up
m_LUX1 = x;
m_LUY1 = y;
m_LUX2 = x;
m_LUY2 = y;

// Left bottom
m_LBX1 = x;
m_LBY1 = y;
m_LBX2 = x;
m_LBY2 = y;

// Right up
m_RUX1 = x;
m_RUY1 = y;
m_RUX2 = x;
m_RUY2 = y;

// Right bottom
m_RBX1 = x;
m_RBY1 = y;
m_RBX2 = x;
m_RBY2 = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the container
var w = m_drawWidth/2;
var h = m_drawHeight/2;

// Draw box
draw_set_color(c_black);
draw_set_alpha(0.2);
draw_rectangle(x - w, y - h, x + w, y + h, false);

draw_set_alpha(1);

// Draw outline
draw_rectangle(x - w, y - h, x + w, y + h, true);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 0
if(m_currentState == 0)
{
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    draw_set_font(fnt_letters);
    
    draw_text(x, y, "Press A to join")
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 1

if(m_currentState == 1)
{
    // Draw the name
    draw_set_color(c_white)
    draw_text_outline(x, y - m_drawHeight/4, m_name, 6, c_black, 360);
    
    // Draw the selector
    for (i=0; i&lt;4; i+=1)
    {
        var angle = i * 90;
        var distance = m_selectorDist + (sin(m_sinCounter) * 5);
        
        var xSelect = m_selectorX + lengthdir_x(distance, angle + 90 + m_selectorAngleOff); //135
        var ySelect = m_selectorY + lengthdir_y(distance, angle + 90 + m_selectorAngleOff); // 135
        
        var xSelect2 = m_selectorX + lengthdir_x(distance * .75, angle + 90 - (45/2) + m_selectorAngleOff); //135
        var ySelect2 = m_selectorY + lengthdir_y(distance * .75, angle + 90 - (45/2) + m_selectorAngleOff); // 135
        
        var xSelect3 = m_selectorX + lengthdir_x(distance * .75, angle + 90 + (45/2) + m_selectorAngleOff); //135
        var ySelect3 = m_selectorY + lengthdir_y(distance * .75, angle + 90 + (45/2) + m_selectorAngleOff); // 135
        
        //draw_sprite_ext(m_selectorPart, -1, xSelect, ySelect, 1, 1, i * 90, c_white, 1);
        
        draw_line(xSelect, ySelect, xSelect2, ySelect2);
        draw_line(xSelect, ySelect, xSelect3, ySelect3);
        
        
    }   
    
    // Draw the letters
    var bwidth = m_drawWidth / m_xRows;
    var bheight = m_drawHeight / m_yRows;
    
    draw_set_color(c_white);
    draw_set_font(fnt_letters);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    
    for (i = 0; i &lt; array_length_1d(m_letterBoxX); i++)
    {
        var xCenter = m_letterBoxX[i] + (bwidth / 2);
        var yCenter = m_letterBoxY[i] + (bheight / 2);
        
        var letter = string_copy(m_alphabet, i + 1, 1);
        draw_set_color(make_color_hsv(i * 255 / array_length_1d(m_letterBoxX), m_letterSat[i], 255));
        draw_set_halign(fa_center);
        draw_set_valign(fa_center);
        
        draw_text_transformed(xCenter, yCenter, letter,
        1, 1, 0)//m_letterRot[i]);
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 2

if(m_currentState == 2)
{
    var w = m_drawWidth;
    var h = m_drawHeight;
    var offset = 0
    if(m_charSelectNormal) { offset = sin(m_sinCounter) * 10; }
        
    // Draw the selector
    draw_set_color(c_white);
    
    // Left arm
    draw_line(m_LUX1 + offset, m_LUY1, m_LUX2 + offset, m_LUY2);
    draw_line(m_LBX1 + offset, m_LBY1, m_LBX2 + offset, m_LBY2);
    
    // Right arm
    draw_line(m_RUX1 - offset, m_RUY1, m_RUX2 - offset, m_RUY2);
    draw_line(m_RBX1 - offset, m_RBY1, m_RBX2 - offset, m_RBY2);
    
    // Draw the sprites
    draw_sprite_ext(spr_hats, m_currentHat, x, y, 2.5, 2.5, 0, c_white, 1);
    draw_sprite_ext(spr_players, m_currentPlayer, x, y + (h/4), 2.5, 2.5, 0, c_white, 1);
    
    // Draw the color
    draw_set_color(make_color_hsv(m_currentColor, 255, 255));
    
    var bSize = 32;
    draw_rectangle(x - bSize, y - (h/4) - bSize,
                    x + bSize, y - (h/4) + bSize, false);
                     
    // Draw ready
    draw_text(x, y + (h/2.5), m_readyText)
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 3

if(m_currentState == 3)
{                 
    draw_set_color(c_white);
    
    
    draw_text_transformed(x, y, "READY!", 
        1 + (cos(m_containterSin * 2) * 0.2), 1 + (sin(m_containterSin * 3) * 0.2), 
        sin(m_sinCounter) * 20)
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
