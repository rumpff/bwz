<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get input

var gpDevice = global.playerGamepadID[m_id];

// Up
if (gamepad_axis_value(gpDevice, gp_axislv) &lt; -m_gpDeadzone)
{
    m_inputUp = input_timers_active(0);
}
else
{   
    // Check for d-pad
    if(gamepad_button_check_pressed(gpDevice, gp_padu))
    {
        m_inputUp = true;
    }
    else
    {
        // Reset all timer values
        m_inputUp = input_timers_reset(0);
    }
}

// Down
if (gamepad_axis_value(gpDevice, gp_axislv) &gt; m_gpDeadzone)
{
    m_inputDown = input_timers_active(1);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(gpDevice, gp_padd))
    {
        m_inputDown = true;
    }
    else
    {
        // Reset all timer values
        m_inputDown = input_timers_reset(0);
    }
}

// Left
if (gamepad_axis_value(gpDevice, gp_axislh) &lt; -m_gpDeadzone)
{
    m_inputLeft = input_timers_active(2);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(gpDevice, gp_padl))
    {
        m_inputLeft = true;
    }
    else
    {
        // Reset all timer values
        m_inputLeft = input_timers_reset(0);
    }
}

// Right
if (gamepad_axis_value(gpDevice, gp_axislh) &gt; m_gpDeadzone)
{
    m_inputRight = input_timers_active(3);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(gpDevice, gp_padr))
    {
        m_inputRight = true;
    }
    else
    {
        // Reset all timer values
        m_inputRight = input_timers_reset(0);
    }
}

// Raw sticks
stickH = gamepad_axis_value(gpDevice, gp_axislh);
stickV = gamepad_axis_value(gpDevice, gp_axislv);

// Buttons
m_inputSelect = gamepad_button_check_pressed(gpDevice, gp_face1);
m_inputBack = gamepad_button_check_pressed(gpDevice, gp_face2);
m_inputTriggerL = gamepad_button_check(gpDevice, gp_shoulderlb);
m_inputTriggerR = gamepad_button_check(gpDevice, gp_shoulderrb);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug mode input keyboard override

if(DEBUG_MODE == 1 &amp;&amp; m_id == 1)
{
    // Up
    m_inputUp = keyboard_check_pressed(vk_up);
    
    // Down
    m_inputDown = keyboard_check_pressed(vk_down);
    
    // Left
    m_inputLeft = keyboard_check_pressed(vk_left);
    
    // Right
    
    m_inputRight = keyboard_check_pressed(vk_right);
    
    // Raw Sticks
    stickH = 1;
    stickV = 0;
    
    // Buttons
    m_inputSelect = keyboard_check_pressed(vk_enter);
    m_inputShift = keyboard_check(vk_lshift);
    m_inputTriggerL = keyboard_check(vk_lshift);
    m_inputTriggerR = keyboard_check(vk_lcontrol);
    m_inputBack = keyboard_check_pressed(vk_escape);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Force ready

if(m_currentState == 3)
{
    m_ready = true;
}
else
{
    m_ready = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update State "Ready"

if(m_currentState == m_selectStates.Ready)
{   
    m_ready = true;

    if(m_inputBack)
    {
        m_ready = false;
        event_user(2);
        exit;
    }
        
    global.playerHead[m_id] = m_currentHead;
    global.playerLeg[m_id] = m_currentLeg;
    global.playerBow[m_id] = m_currentBow;
    global.playerHat[m_id] = m_currentHat;
    global.playerColor[m_id] = make_color_hsv(m_currentColor, 255, 255);
    global.playerName[m_id] = m_name;
    
    if (m_uwahTimer == 30)
    {
        var sound;
        
        switch(m_id)
        {
            case 0:
                sound = snd_uwah1;
                break;  
                
            case 1:
                sound = snd_uwah2;
                break;
                
            case 2:
                sound = snd_uwah3;
                break;
                
            case 3:
                sound = snd_uwah4;
                break; 
        }
        
        audio_play_sound(sound, 1, 0);
    }
    
    m_uwahTimer++;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update State "EnterName"

if(m_currentState == m_selectStates.EnterName)
{
    // Set charset
    if(m_inputTriggerL &amp;&amp; m_inputTriggerR) { m_charsetCurrent = m_charsetD; }
    else if(m_inputTriggerL &amp;&amp; !m_inputTriggerR) { m_charsetCurrent = m_charsetC; }
    else if(!m_inputTriggerL &amp;&amp; m_inputTriggerR) { m_charsetCurrent = m_charsetB; }
    else { m_charsetCurrent = m_charsetA; }
    
    // Animate selecor
    m_selectorDist = lerp(m_selectorDist, m_selectorMaxDistance, 0.17);
    m_selectorAngleOff = lerp(m_selectorAngleOff, 0, 0.17);
    
    // Set all the positions for the letters
    m_letterBoxX[0] = 0;
    m_letterBoxY[0] = 0;  
    
    
    var sx = x - m_contWidth/2;
    var sy = y - m_contHeight/6;
    
    var boxIndex = 0;
    
    var bwidth = m_contWidth / m_xRows;
    var bheight = m_contHeight / m_yRows;
    
    for (iy = 0; iy &lt; 8; iy++)
    {
        for (ix = 0; ix &lt; 4; ix++)
        {
            if(boxIndex &lt; string_length(m_charsetCurrent))
            {
                m_letterBoxX[boxIndex] = sx + (ix * bwidth); // left x
                m_letterBoxY[boxIndex] = sy + (iy * bheight * 0.66); // upper y
                
                boxIndex++;
            }
        }    
    }
    
    
    // Get input from the selection
    if(m_inputSelect)
    {
        var newLetter = string_copy(m_charsetCurrent, m_selectorPos+1, 1);
        var nameLength = string_length(m_name);
        m_letterRot[m_selectorPos] = choose(-30, 30);
        m_letterSat[m_selectorPos] = 255;
        m_selectorDist = m_clickDistance;
        
        switch(newLetter)
        {
            case "&lt;":
                // Remove a letter   
                m_name = string_delete(m_name, nameLength, 1);
                audio_play_sound(snd_letterRemove, 1, 0);
                m_selectorAngleOff = -90;
                break;
                
            case "&gt;":
                // Goto next state
                if(nameLength &gt; 0) // name isn't empty
                {
                    event_user(1);
                }
                break;
                
            default:
                // Add the letter
                if(nameLength &lt; m_maxNameLength)
                { 
                    m_name += newLetter;
                    var snd = audio_play_sound(snd_letterEnter, 1, 0);
                    audio_sound_pitch(snd, random_range(.9, 1.1));
                }
                else
                {
                    // name at limit
                }
                
                if (nameLength == m_maxNameLength) // Move the cursor to confirm if the max length is reached
                {
                    m_selectorPos = array_length_1d(m_letterBoxX)-1;
                    audio_play_sound(snd_letterFull, 1, 0);
                }
                
                m_selectorAngleOff = 90;
                break;
        }
    }
    
    if(m_inputBack)
    {  
        var nameLength = string_length(m_name);
        if(nameLength &gt; 0) // Remove a letter 
        {
            m_name = string_delete(m_name, nameLength, 1);
            audio_play_sound(snd_letterRemove, 1, 0);
            m_selectorAngleOff = -90;
        }
        else
        {
            event_user(2);
            exit;
        }
    }
    
    // Move the selection
    var addAmount = 0;
    
    if(m_inputUp &amp;&amp; (m_selectorPos - m_xRows) &gt;= 0)
    {
        // Move up
        addAmount -= m_xRows;
    }
    if(m_inputDown &amp;&amp; (m_selectorPos + m_xRows) &lt; array_length_1d(m_letterBoxX))
    {
        // Move down
        addAmount += m_xRows;
    }  
    if(m_inputLeft &amp;&amp; ((m_selectorPos-1+m_xRows) mod m_xRows) != m_xRows-1)
    {
        // Move left
        addAmount--;
    }
    if(m_inputRight &amp;&amp; ((m_selectorPos+1+m_xRows) mod m_xRows) != 0 &amp;&amp; m_selectorPos+1 &lt; array_length_1d(m_letterBoxX))
    {
        // Move right
        addAmount++;
    }
    
    if(addAmount != 0) 
    { 
        m_selectorPos += addAmount;
        m_selectorDist =  (m_selectorMaxDistance * .8); 
        audio_play_sound(snd_cursorMove, 1, 0);
    }
    
    // Set the selector's position
    m_selectorX = lerp(m_selectorX, m_letterBoxX[m_selectorPos] + (bwidth / 2), 0.4);
    m_selectorY = lerp(m_selectorY, m_letterBoxY[m_selectorPos] + (bheight / 2), 0.4);
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update State "Create Character"

if(m_currentState == m_selectStates.SelectCharacter)
{   
    var w = m_contWidth;
    var h = m_contHeight;

    // Lerp the selector pos
    switch(m_charCurrent)
    {
        case 0:
            m_charSelectPos = lerp(m_charSelectPos, y - (h/4), 1);
            m_charSelectState = 1;
            break;
            
        case 1:
            m_charSelectPos = lerp(m_charSelectPos, y, 1);
            m_charSelectState = 0;
            break;
            
        case 2:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/6), 1);
            m_charSelectState = 0;
            break;
        
        case 3:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/4), 1);
            m_charSelectState = 0;          
            break;
            
        case 4:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/4) + (12*2.5) , 1);
            m_charSelectState = 0;          
            break;
            
        case 5:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/2.5), 1);
            m_charSelectState = 2;
            break;
    }
    
    m_charSLOffset = lerp(m_charSLOffset, 0, 0.2);
    m_charSROffset = lerp(m_charSROffset, 0, 0.2);

    // Set the ready text
    if(m_charCurrent == 5)
    {  m_readyText = "READY?"; }
    else { m_readyText = "READY"; }
    
    // Check the inputs    
    if(m_inputSelect)
    {
        if(m_charCurrent == 5)
        {
            event_user(1);
            audio_play_sound(snd_swordSlice, 1, 0);
            m_uwahTimer = 0;
        }
        else
        {
            m_charCurrent++; 
            var snd = audio_play_sound(snd_sweep, 1, 0);
            audio_sound_pitch(snd, 1 + (m_charCurrent * 0.1));
        }
    }
    
    if(m_inputBack)
    {
        if(m_charCurrent &gt; 0)
        {
            m_charCurrent--; 
            var snd = audio_play_sound(snd_sweep, 1, 0);
            audio_sound_pitch(snd, 1 + (m_charCurrent * 0.1));
        }
        else
        {
            event_user(2);
            exit;
        }
    }
    
    
    if (m_inputLeft)
    {
        var valid = false;
        
        switch(m_charCurrent)
        {       
           case 1:
                if (m_currentBow &gt; 0) 
                { 
                    m_currentBow--; 
                    m_bowXOffset -= 16; 
                    valid = true;
                }
                break;
                
            case 2:
                if (m_currentHat &gt; 0) 
                { 
                    m_currentHat--; 
                    m_hatXOffset -= 16; 
                    valid = true;
                }
                break;
                
            case 3:
                if (m_currentHead &gt; 0) 
                { 
                    m_currentHead--; 
                    m_headXOffset -= 16;
                    valid = true;
                }
                break;
                
            case 4:
                if (m_currentLeg &gt; 0) 
                { 
                    m_currentLeg--; 
                    m_legXOffset -= 16;
                    valid = true;
                }
                break;
        }
        
        if(valid)
        { m_charSLOffset = 16; audio_play_sound(snd_sweep, 1, 0); }
    }
    
    if (m_inputRight)
    {
        var valid = false;
        
        switch(m_charCurrent)
        {       
            case 1:
                if (m_currentBow &lt; BOW_AMOUNT-1) 
                { 
                    m_currentBow++; 
                    m_bowXOffset += 16;
                    valid = true;
                }
                break;
                
            case 2:
                if (m_currentHat &lt; (sprite_get_number(spr_hats) - 1)) 
                { 
                    m_currentHat++; 
                    m_hatXOffset += 16; 
                    valid = true;
                }
                break;
                
            case 3:
                if (m_currentHead &lt; HEAD_AMOUNT-1) 
                { 
                    m_currentHead++; 
                    m_headXOffset += 16;
                    valid = true;
                }
                break;
                
            case 4:
                if (m_currentLeg &lt; LEG_AMOUNT-1) 
                { 
                    m_currentLeg++; 
                    m_legXOffset += 16;
                    valid = true;
                }
                break;
        }
        
        if (valid)
        { m_charSROffset = 16; audio_play_sound(snd_sweep, 1, 0); }
    }
    
    if(m_charCurrent == 0)
    {
        var angle = point_direction(0, 0, stickH, stickV);
        
        if(max(abs(stickH), abs(stickV)) &gt; 0.3)
        {
            m_currentColor = floor(angle / 360 * 255);
        }
    }   
    //m_currentColor += m_colorAmount;
    
    // Lerp thumbs    
    m_bowThumbOffset = lerp(m_bowThumbOffset, (m_charCurrent == 1), 0.2);
    m_hatThumbOffset = lerp(m_hatThumbOffset, (m_charCurrent == 2), 0.2);
    m_headThumbOffset = lerp(m_headThumbOffset, (m_charCurrent == 3), 0.2);
    m_legThumbOffset = lerp(m_legThumbOffset, (m_charCurrent == 4), 0.2);
     
    m_bowXOffset = lerp(m_bowXOffset, 0, 0.35);       
    m_hatXOffset = lerp(m_hatXOffset, 0, 0.35);
    m_headXOffset = lerp(m_headXOffset, 0, 0.35);
    m_legXOffset = lerp(m_legXOffset, 0, 0.35);
    
    
    // Animate the color wheel
    for (i = 0; i &lt; 255; i++)
    { 
        var dest;
        
        //if((m_currentColor / 17) mod (255 / m_colorAmount) == i)
        //{ dest = 12; } else { dest = 0; }
        
        dest = abs(angle_difference(m_currentColor/255*360, i/255*360));
        
        //dest = clamp(dest, 0, 32 * (m_charCurrent == 0));
        dest = lerp(0, dest, 2);
        dest = clamp(dest, 0, m_colorClamp);
        
        dest = dest * (m_charCurrent == 0);
        
        m_colDist[i] = lerp(m_colDist[i], dest, 0.4); 
    }
    
    // Set selector cordinates
    if(m_charSelectState == 0) // normal arrows
    {
        var lerpVal = 0.33;
        
        // Left up
        m_LUX1 = lerp(m_LUX1, x - 128 - m_charSLOffset, lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos, lerpVal);
        m_LUX2 = lerp(m_LUX2, x - 96 - m_charSLOffset, lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos - 32, lerpVal);
        
        // Left bottom    
        m_LBX1 = lerp(m_LBX1, x - 128 - m_charSLOffset, lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos, lerpVal);
        m_LBX2 = lerp(m_LBX2, x - 96 - m_charSLOffset, lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + 32, lerpVal);
    
        // Right up
        m_RUX1 = lerp(m_RUX1, x + 128 + m_charSROffset, lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos, lerpVal);
        m_RUX2 = lerp(m_RUX2, x + 96 + m_charSROffset, lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos - 32, lerpVal);
        
        // Right bottom      
        m_RBX1 = lerp(m_RBX1, x + 128 + m_charSROffset, lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos, lerpVal);
        m_RBX2 = lerp(m_RBX2, x + 96 + m_charSROffset, lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + 32, lerpVal);
    }
    else if(m_charSelectState == 1) // Selector is on colorWheel
    {
        var lerpVal = 0.33;
        var angle = m_currentColor / 255 * 360;
        
        // Up
        m_LUX1 = lerp(m_LUX1, x + lengthdir_x(m_cWheelDist, angle-90), lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos + lengthdir_y(m_cWheelDist, angle-90), lerpVal);
        m_LUX2 = lerp(m_LUX2, x + lengthdir_x(m_cWheelDist, angle - 5), lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos + lengthdir_y(m_cWheelDist, angle - 5), lerpVal);
        
        // Left    
        m_LBX1 = lerp(m_LBX1, x + lengthdir_x(m_cWheelDist, angle-90), lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos + lengthdir_y(m_cWheelDist, angle-90), lerpVal);
        m_LBX2 = lerp(m_LBX2, x + lengthdir_x(m_cWheelDist, angle+180), lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + lengthdir_y(m_cWheelDist, angle+180), lerpVal);
    
        // Right
        m_RUX2 = lerp(m_RUX2, x + lengthdir_x(m_cWheelDist, angle+90), lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos + lengthdir_y(m_cWheelDist, angle+90), lerpVal);
        m_RUX1 = lerp(m_RUX1, x + lengthdir_x(m_cWheelDist, angle + 5), lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos + lengthdir_y(m_cWheelDist, angle + 5), lerpVal);
        
        // Bottom 
        m_RBX1 = lerp(m_RBX1, x + lengthdir_x(m_cWheelDist, angle+90), lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos + lengthdir_y(m_cWheelDist, angle+90), lerpVal);
        m_RBX2 = lerp(m_RBX2, x + lengthdir_x(m_cWheelDist, angle+180), lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + lengthdir_y(m_cWheelDist, angle+180), lerpVal);
    }
    else if(m_charSelectState == 2) // Selector is on ready
    {
        var lerpVal = 0.33;
        var tWidth = string_width(m_readyText) + 16;
        var tHeight = string_height(m_readyText) + 2;
        
        // Up
        m_LUX1 = lerp(m_LUX1, x - (tWidth/2) - 1, lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos - (tHeight/2), lerpVal);
        m_LUX2 = lerp(m_LUX2, x + (tWidth/2), lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos - (tHeight/2), lerpVal);
        
        // Left    
        m_LBX1 = lerp(m_LBX1, x - (tWidth/2), lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos - (tHeight/2), lerpVal);
        m_LBX2 = lerp(m_LBX2, x - (tWidth/2), lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + (tHeight/2), lerpVal);
    
        // Right
        m_RUX2 = lerp(m_RUX2, x + (tWidth/2), lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos - (tHeight/2), lerpVal);
        m_RUX1 = lerp(m_RUX1, x + (tWidth/2), lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos + (tHeight/2), lerpVal);
        
        // Bottom 
        m_RBX1 = lerp(m_RBX1, x + (tWidth/2), lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos + (tHeight/2), lerpVal);
        m_RBX2 = lerp(m_RBX2,  x - (tWidth/2), lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + (tHeight/2), lerpVal);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update State "PressA"

if(m_currentState == m_selectStates.PressA)
{    
    /* // Check for input
    if (m_inputSelect) // Go to the next state
    { 
        audio_play_sound(snd_pressedA, 1, 0); 
        m_currentState++; 
        obj_drawRays.m_multiplier += 5;
    }*/ 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Reset values to default</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset values to default

global.playerGamepadID[m_id] = -1

m_currentColor = (180.0 + 50.0 + (m_id * 90.0)) / 360.0 * 255.0 % 255.0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Previous State</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>m_currentState--;
audio_play_sound(snd_charReturn, 1, 0);

if(m_currentState == m_selectStates.PressA)
    event_user(3); // Reset to default
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Next State</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>m_currentState++;
audio_play_sound(snd_charNext, 1, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Initualize</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize variables

enum m_selectStates // The states where the box can be in
{
    PressA = 0,
    SelectCharacter = 1,
    EnterName = 2,
    Ready = 3
}

m_keybaord = false;
m_currentState = 0; // The current state of the box
m_ready = false;
//m_totalAmount = noone; // The total amount of this object, used for positioning

m_contWidth = 480; // The width of the container
m_contHeight = 810; // The height of the container

m_uwahTimer = 0;

/// Input
m_gpDeadzone = 0.3;

m_inputUp = false;
m_inputDown = false;
m_inputLeft = false;
m_inputRight = false;
m_inputSelect = false;
m_inputBack = false;

m_inputTimerMax = 22;
m_inputTimerMin = 10;

for (i = 0; i &lt; 4; i++) // 0 = up, 1 = down, 2 = left, 3 = right
{
    m_inputTimer[i] = 0;
    m_inputTimerCurrent[i] = m_inputTimerMax;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set position

y = 675;
x = room_width / 4 * (m_id+1) - room_width / 8;

/*
x = room_width / 4 * ((m_controllerId % 2 == 1) + 1);
y = room_height / 4 * ((m_controllerId &gt; 1) + 1);

x += room_width / 2;
y += room_height / 2;
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State "Enter Name" specifics

var b2b = sqrt(sqr(16) * 2); // Selector's with to exact touch borders

m_selectorMaxDistance = b2b * 1.5;
m_clickDistance = b2b / 1.5;

m_charsetA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;&gt;";
m_charsetB = "abcdefghijklmnopqrstuvwxyz&lt;&gt;";
m_charsetC = "ÀÂÃÄÆÇÈÉÊËÌÍÎÏÑÒÓÔÕÖØŒÙÛÜß&lt;&gt;";
m_charsetD = "0123456789?!@$%^&amp;*/()™~_. &lt;&gt;";
m_charsetCurrent = m_charsetA;


m_letterBoxX[0] = 0;
m_letterBoxY[0] = 0;

m_xRows = 4;
m_yRows = 8;

m_selectorPos = 0;
m_selectorX = x;
m_selectorY = y;
m_selectorDist = 0;
m_selectorAngleOff = 0;

m_name = ""; // The name that the player enters
m_maxNameLength = string_length("broodroost3r");
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State "Select Character" specifics

m_currentBow = 0;
m_currentHead = 0;
m_currentLeg = 0;
m_currentHat = 0;
m_currentColor = 0;

m_colorClamp = 42;

m_colorAmount = 17;
for (i = 0; i &lt; 255; i++)
{ m_colDist[i] = 0; }

m_charCurrent = 0;
m_charSelectPos = y;
m_charSelectState = 0;

m_bowThumbOffset = 0;
m_headThumbOffset = 0;
m_legThumbOffset = 0;
m_hatThumbOffset = 0;

m_bowXOffset = 0;
m_headXOffset = 0;
m_legXOffset = 0;
m_hatXOffset = 0;

m_readyText = "READY"

m_cWheelDist = 32; // Distance from innner circle of the color wheel

// Offset from the selectors xpos
m_charSLOffset = 0;
m_charSROffset = 0;

// Coordinates for the selector lines

// Left up
m_LUX1 = x;
m_LUY1 = y;
m_LUX2 = x;
m_LUY2 = y;

// Left bottom
m_LBX1 = x;
m_LBY1 = y;
m_LBX2 = x;
m_LBY2 = y;

// Right up
m_RUX1 = x;
m_RUY1 = y;
m_RUX2 = x;
m_RUY2 = y;

// Right bottom
m_RBX1 = x;
m_RBY1 = y;
m_RBX2 = x;
m_RBY2 = y;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset values to default

event_user(3);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the container

var w = m_contWidth/2;
var h = m_contHeight/2;

// Draw box
draw_set_color(make_colour_hsv(m_currentColor,255,255));
draw_rectangle(x - w, y - h, x + w, y + h, false);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw state "PressA"
if(m_currentState == m_selectStates.PressA)
{  
    // override container
    var w = m_contWidth/2;
    var h = m_contHeight/2;
    
    // Draw box
    draw_set_color(c_black);
    draw_rectangle(x - w, y - h, x + w, y + h, false);
    
    var o = 10; // outline offset
    draw_set_color(c_white);
    draw_rectangle(x - w + o, y - h + o, x + w - o, y + h - o, true);

    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    draw_set_font(fnt_letters);
    draw_text(x, y, "PRESS
START")
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw state "Select Character"

if(m_currentState == m_selectStates.SelectCharacter)
{
    var w = m_contWidth;
    var h = m_contHeight;
    var offset = 0
    //if(m_charSelectState == 0) { offset = sin(m_sinCounter) * 10; }
    if(m_charSelectState == 0) { offset = 10; }
        
    // Draw the selector
    draw_set_color(c_white);
    
    // Left arm
    draw_line(m_LUX1 + offset, m_LUY1, m_LUX2 + offset, m_LUY2);
    draw_line(m_LBX1 + offset, m_LBY1, m_LBX2 + offset, m_LBY2);
    
    // Right arm
    draw_line(m_RUX1 - offset, m_RUY1, m_RUX2 - offset, m_RUY2);
    draw_line(m_RBX1 - offset, m_RBY1, m_RBX2 - offset, m_RBY2);
    
    //if(m_charSelectState == 1) // Selector is on colorWheel
    {
        draw_set_color(make_color_hsv(m_currentColor, 255, 255));
        draw_set_circle_precision(4);
        
        draw_circle(x, y - (h/4), 12, false);
        draw_set_color(c_black)
        draw_circle(x, y - (h/4), 12, true);
        
        // Reset the precision
        draw_set_circle_precision(24);
    }
    
    // Draw the bow
    if(m_currentBow+1 &lt; BOW_AMOUNT)
    { draw_sprite_ext(bow_sprite(m_currentBow+1), 0, x + (64 * m_bowThumbOffset) + m_bowXOffset, y, 1 * m_bowThumbOffset, 1 * m_bowThumbOffset, 0, c_white, 0.5); }
    if(m_currentBow-1 &gt;= 0)
    { draw_sprite_ext(bow_sprite(m_currentBow-1), 0, x - (64 * m_bowThumbOffset) + m_bowXOffset, y, 1 * m_bowThumbOffset, 1 * m_bowThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentBow+2 &lt; BOW_AMOUNT)
    { draw_sprite_ext(bow_sprite(m_currentBow+2), 0, x + (96 * m_bowThumbOffset) + m_bowXOffset, y, 0.5 * m_bowThumbOffset, 0.5 * m_bowThumbOffset, 0, c_white, 0.5); }
    if(m_currentBow-2 &gt;= 0)
    { draw_sprite_ext(bow_sprite(m_currentBow-2), 0, x - (96 * m_bowThumbOffset) + m_bowXOffset, y, 0.5 * m_bowThumbOffset, 0.5 * m_bowThumbOffset, 0, c_white, 0.5); }
    
    draw_sprite_ext(bow_sprite(m_currentBow), 0, x + m_bowXOffset, y, 2.5, 2.5, 0, c_white, 1);
    
    // Draw the hat
    if(m_currentHat+1 &lt; sprite_get_number(spr_hats))
    { draw_sprite_ext(spr_hats, m_currentHat+1, x + (64 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 1 * m_hatThumbOffset, 1 * m_hatThumbOffset, 0, c_white, 0.5); }
    if(m_currentHat-1 &gt;= 0)
    { draw_sprite_ext(spr_hats, m_currentHat-1, x - (64 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 1 * m_hatThumbOffset, 1 * m_hatThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentHat+2 &lt; sprite_get_number(spr_hats))
    { draw_sprite_ext(spr_hats, m_currentHat+2, x + (96 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 0.5 * m_hatThumbOffset, 0.5 * m_hatThumbOffset, 0, c_white, 0.5); }
    if(m_currentHat-2 &gt;= 0)
    { draw_sprite_ext(spr_hats, m_currentHat-2, x - (96 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 0.5 * m_hatThumbOffset, 0.5 * m_hatThumbOffset, 0, c_white, 0.5); }
    
    draw_sprite_ext(spr_hats, m_currentHat, x + m_hatXOffset, y + (h/6), 2.5, 2.5, 0, c_white, 1);
    
    
    // Legs
    if(m_currentLeg+1 &lt; LEG_AMOUNT)
    { draw_sprite_ext(leg_sprite(m_currentLeg+1), 0, x - (8) + (64 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12*2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); 
        draw_sprite_ext(leg_sprite(m_currentLeg+1), 0, x + (8) + (64 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12*2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); }
        
    if(m_currentLeg-1 &gt;= 0)
    { draw_sprite_ext(leg_sprite(m_currentLeg-1), 0, x - (8) - (64 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); 
        draw_sprite_ext(leg_sprite(m_currentLeg-1), 0, x + (8) - (64 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentLeg+2 &lt; LEG_AMOUNT)
    { draw_sprite_ext(leg_sprite(m_currentLeg+2), 0, x - (8 * 0.5) + (96 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5); 
       draw_sprite_ext(leg_sprite(m_currentLeg+2), 0, x + (8 * 0.5) + (96 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5);}
    
    if(m_currentLeg-2 &gt;= 0)
    { draw_sprite_ext(leg_sprite(m_currentLeg-2), 0, x - (8 * 0.5) - (96 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5); 
       draw_sprite_ext(leg_sprite(m_currentLeg-2), 0, x + (8 * 0.5) - (96 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5);}
    
    draw_sprite_ext(leg_sprite(m_currentLeg), 0, x - (8 * 2.5) + m_legXOffset, y + (h / 4) + (12 * 2.5) , 2.5, 2.5, 0, c_white, 1)
    draw_sprite_ext(leg_sprite(m_currentLeg), 0, x + (8 * 2.5) + m_legXOffset, y + (h / 4) + (12 * 2.5) , 2.5, 2.5, 0, c_white, 1)
    
    // Head
    if(m_currentHead+1 &lt; HEAD_AMOUNT)
    { draw_sprite_ext(head_sprite(m_currentHead+1), 0, x + (64 * m_headThumbOffset) + m_headXOffset, y + (h/4), 1 * m_headThumbOffset, 1 * m_headThumbOffset, 0, c_white, 0.5); }
    if(m_currentHead-1 &gt;= 0)
    { draw_sprite_ext(head_sprite(m_currentHead-1), 0, x - (64 * m_headThumbOffset) + m_headXOffset, y + (h/4), 1 * m_headThumbOffset, 1 * m_headThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentHead+2 &lt; HEAD_AMOUNT)
    { draw_sprite_ext(head_sprite(m_currentHead+2), 0, x + (96 * m_headThumbOffset) + m_headXOffset, y + (h/4), 0.5 * m_headThumbOffset, 0.5 * m_headThumbOffset, 0, c_white, 0.5); }
    if(m_currentHead-2 &gt;= 0)
    { draw_sprite_ext(head_sprite(m_currentHead-2), 0, x - (96 * m_headThumbOffset) + m_headXOffset, y + (h/4), 0.5 * m_headThumbOffset, 0.5 * m_headThumbOffset, 0, c_white, 0.5); }
      
    draw_sprite_ext(head_sprite(m_currentHead), 0, x + m_headXOffset, y + (h/4), 2.5, 2.5, 0, c_white, 1);
    
    // Color block
    draw_set_color(make_color_hsv(m_currentColor, 255, 255));
                    
    // Color circle
    for (i = 0; i &lt; 255; i++) //(255 / m_colorAmount)
    {
        var colorAmount = 255; //(255 / m_colorAmount)
        var angleOff = 0;
        
        var sizeTop = m_cWheelDist + 16 + m_colDist[i] + (16 * (m_charSelectState == 1));
        var sizeBottom = m_cWheelDist + m_colDist[i];
        
        var x1 = x + lengthdir_x(sizeTop, i * (360 / colorAmount) + angleOff);
        var y1 = y - (h/4) + lengthdir_y(sizeTop, i * (360 / colorAmount) + angleOff);
        
        var x2 = x + lengthdir_x(sizeTop, (i+1) * (360 / colorAmount) + angleOff);
        var y2 = y - (h/4) + lengthdir_y(sizeTop, (i+1) * (360 / colorAmount) + angleOff);
        
        var x3 = x + lengthdir_x(sizeBottom, i * (360 / colorAmount) + angleOff);
        var y3 = y - (h/4) + lengthdir_y(sizeBottom, i * (360 / colorAmount) + angleOff);
        
        var x4 = x + lengthdir_x(sizeBottom, (i+1) * (360 / colorAmount) + angleOff);
        var y4 = y - (h/4) + lengthdir_y(sizeBottom, (i+1) * (360 / colorAmount) + angleOff);
        
        draw_set_color(make_color_hsv(i * m_colorAmount / 17, 255, 255));        
        draw_paralellogram(x1, y1, x2, y2, x3, y3, x4, y4, false);
        
        draw_set_color(c_black);
        draw_line(x1, y1, x2, y2)
        draw_line(x3, y3, x4, y4);
        
    }
                     
    // Draw ready
    draw_set_color(make_color_hsv(m_currentColor, 255, 255));
    draw_text_outline(x, y + (h/2.5), m_readyText, 1, c_black, 64);
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw state "Enter Name"

if(m_currentState == m_selectStates.EnterName)
{
    var textColor = make_colour_hsv((m_currentColor + 128) % 255,255,255);

    // Draw the name
    draw_set_color(textColor)
    draw_text(x, y - m_contHeight/4, m_name);
    
    // Draw the selector
    for (i=0; i&lt;4; i+=1)
    {
        var angle = i * 90;
        var distance = m_selectorDist;
        
        var xSelect = m_selectorX + lengthdir_x(distance, angle + 90 + m_selectorAngleOff); //135
        var ySelect = m_selectorY + lengthdir_y(distance, angle + 90 + m_selectorAngleOff); // 135
        
        var xSelect2 = m_selectorX + lengthdir_x(distance * .75, angle + 90 - (45/2) + m_selectorAngleOff); //135
        var ySelect2 = m_selectorY + lengthdir_y(distance * .75, angle + 90 - (45/2) + m_selectorAngleOff); // 135
        
        var xSelect3 = m_selectorX + lengthdir_x(distance * .75, angle + 90 + (45/2) + m_selectorAngleOff); //135
        var ySelect3 = m_selectorY + lengthdir_y(distance * .75, angle + 90 + (45/2) + m_selectorAngleOff); // 135
        
        //draw_sprite_ext(m_selectorPart, -1, xSelect, ySelect, 1, 1, i * 90, c_white, 1);
        
        draw_line(xSelect, ySelect, xSelect2, ySelect2);
        draw_line(xSelect, ySelect, xSelect3, ySelect3);
        
        
    }   
    
    // Draw the letters
    var spacing = 5;
    var bwidth = m_contWidth / m_xRows;
    var bheight = m_contHeight / m_yRows;
    
    draw_set_color(textColor);
    draw_set_font(fnt_letters);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    
    for (i = 0; i &lt; array_length_1d(m_letterBoxX); i++)
    {
        var xCenter = m_letterBoxX[i] + (bwidth / 2);
        var yCenter = m_letterBoxY[i] + (bheight / 2);
        
        var letter = string_copy(m_charsetCurrent, i + 1, 1);
        draw_set_halign(fa_center);
        draw_set_valign(fa_center);
        
        draw_text_transformed(xCenter, yCenter, letter,
        1, 1, 0)//m_letterRot[i]);
    }
    
    draw_set_color(c_red);
    draw_text(x,y,string(string_width("m"))+"px")
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw state "Ready"

if(m_currentState == 3)
{                 
    draw_set_color(c_white);
    
    
    draw_text(x, y, "READY!");
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
