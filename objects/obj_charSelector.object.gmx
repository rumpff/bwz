<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get input
// Up
if (gamepad_axis_value(m_controllerId, gp_axislv) &lt; -m_gpDeadzone)
{
    m_inputUp = input_timers_active(0);
}
else
{   
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padu))
    {
        m_inputUp = true;
    }
    else
    {
        // Reset all timer values
        m_inputUp = input_timers_reset(0);
    }
}

// Down
if (gamepad_axis_value(m_controllerId, gp_axislv) &gt; m_gpDeadzone)
{
    m_inputDown = input_timers_active(1);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padd))
    {
        m_inputDown = true;
    }
    else
    {
        // Reset all timer values
        m_inputDown = input_timers_reset(0);
    }
}

// Left
if (gamepad_axis_value(m_controllerId, gp_axislh) &lt; -m_gpDeadzone)
{
    m_inputLeft = input_timers_active(2);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padl))
    {
        m_inputLeft = true;
    }
    else
    {
        // Reset all timer values
        m_inputLeft = input_timers_reset(0);
    }
}

// Right
if (gamepad_axis_value(m_controllerId, gp_axislh) &gt; m_gpDeadzone)
{
    m_inputRight = input_timers_active(3);
}
else
{
    // Check for d-pad
    if(gamepad_button_check_pressed(m_controllerId, gp_padr))
    {
        m_inputRight = true;
    }
    else
    {
        // Reset all timer values
        m_inputRight = input_timers_reset(0);
    }
}

// Buttons
m_inputSelect = gamepad_button_check_pressed(m_controllerId, gp_face1);
m_inputShift = gamepad_button_check(m_controllerId, gp_shoulderrb);
m_inputBack = gamepad_button_check_pressed(m_controllerId, gp_face2);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Get input keyboar

if(m_id == 1)
{
    // Up
    m_inputUp = keyboard_check_pressed(vk_up);
    
    // Down
    m_inputDown = keyboard_check_pressed(vk_down);
    
    // Left
    m_inputLeft = keyboard_check_pressed(vk_left);
    
    // Right
    
    m_inputRight = keyboard_check_pressed(vk_right);
    
    // Buttons
    m_inputSelect = keyboard_check_pressed(vk_enter);
    m_inputShift = keyboard_check(vk_lshift);
    m_inputBack = keyboard_check_pressed(vk_escape);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// BoxUpdate

// Lerp the size
m_drawWidth = lerp(m_drawWidth, m_contWidth, 0.2) + (cos(m_containterSin) * 2);
m_drawHeight = lerp(m_drawHeight, m_contHeight, 0.2) + (sin(m_containterSin) * 2);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Do tings for all states

if((m_inputBack) &amp;&amp; (m_currentState &gt; 0))
{
    m_currentState--;
    audio_play_sound(snd_charReturn, 1, 0);
    obj_drawRays.m_multiplier -= 5;
}

m_sinCounter += 0.03;
m_containterSin -= 0.07;

if(m_currentState == 3)
{
    m_ready = true;
}
else
{
    m_ready = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 3

if(m_currentState == 3)
{   
    var w = m_drawWidth;
    var h = m_drawHeight;
    
    // set the container to the right size   
    m_contWidth = 250;
    m_contHeight = 125;

    
    global.playerHead[m_id] = m_currentHead;
    global.playerLeg[m_id] = m_currentLeg;
    global.playerHat[m_id] = m_currentHat;
    global.playerColor[m_id] = make_color_hsv(m_currentColor, 255, 255);
    global.playerName[m_id] = m_name;
    
    if (m_uwahTimer == 30)
    {
        var sound;
        
        switch(m_id)
        {
            case 0:
                sound = snd_uwah1;
                break;  
                
            case 1:
                sound = snd_uwah2;
                break;
                
            case 2:
                sound = snd_uwah3;
                break;
                
            case 3:
                sound = snd_uwah4;
                break; 
        }
        
        audio_play_sound(sound, 1, 0);
    }
    
    m_uwahTimer++;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 2

if(m_currentState == 2)
{   
    var w = m_drawWidth;
    var h = m_drawHeight;
    
    // set the container to the right size   
    m_contHeight = 750;
    
    if(m_drawHeight &gt; 740)
    {
        m_contWidth = 350; 
    }
    
    // Set the text
    switch(m_charCurrent)
    {
        case 0:
            m_topText = "Pick a color";
            m_bottomText = "";
            break;
            
        case 1:
            m_topText = "Choose a hat";
            m_bottomText = "";
            break;
        
        case 2:
            m_topText = "Pick your head";
            m_bottomText = "";          
            break;
            
        case 3:
            m_topText = "Choose your legs";
            m_bottomText = "";     
            break;
            
        case 4:
            m_topText = "";
            m_bottomText = "";
            break;
    }
    
    // Lerp the selector pos
    switch(m_charCurrent)
    {
        case 0:
            m_charSelectPos = lerp(m_charSelectPos, y - (h/4), 1);
            m_charSelectNormal = true;
            break;
            
        case 1:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/6), 1);
            m_charSelectNormal = true;
            break;
        
        case 2:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/4), 1);
            m_charSelectNormal = true;          
            break;
            
        case 3:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/4) + (12*2.5) , 1);
            m_charSelectNormal = true;          
            break;
            
        case 4:
            m_charSelectPos = lerp(m_charSelectPos, y + (h/2.5), 1);
            m_charSelectNormal = false;
            break;
    }
    
    m_charSLOffset = lerp(m_charSLOffset, 0, 0.2);
    m_charSROffset = lerp(m_charSROffset, 0, 0.2);

    // Set the ready text
    if(m_charCurrent == 4)
    {  m_readyText = "READY?"; }
    else { m_readyText = "READY"; }
    
    // Check the inputs    
    if(m_inputSelect)
    {
        if(m_charCurrent == 4)
        {
            m_currentState++;
            audio_play_sound(snd_swordSlice, 1, 0);
            m_uwahTimer = 0;
            obj_drawRays.m_multiplier += 10;
        }
        else
        {
            m_charCurrent++; 
            var snd = audio_play_sound(snd_sweep, 1, 0);
            audio_sound_pitch(snd, 1 + (m_charCurrent * 0.1));
        }
    }
    
    if (m_inputUp)
    {
        if(m_charCurrent &gt; 0)
        { m_charCurrent--; audio_play_sound(snd_cursorMove, 1, 0); }
    }
    
    if (m_inputDown)
    {
        if(m_charCurrent &lt; 4)
        { m_charCurrent++; audio_play_sound(snd_cursorMove, 1, 0); }
    }
    
    if (m_inputLeft)
    {
        var valid = false;
        
        switch(m_charCurrent)
        {
            case 0:
                if(m_currentColor &gt;= 255)
                { m_currentColor = 0; }
                
                m_currentColor += m_colorAmount;

                valid = true;
                break;
                
            case 1:
                if (m_currentHat &gt; 0) 
                { 
                    m_currentHat--; 
                    m_hatXOffset -= 16; 
                    valid = true;
                }
                break;
                
            case 2:
                if (m_currentHead &gt; 0) 
                { 
                    m_currentHead--; 
                    m_headXOffset -= 16;
                    valid = true;
                }
                break;
                
            case 3:
                if (m_currentLeg &gt; 0) 
                { 
                    m_currentLeg--; 
                    m_legXOffset -= 16;
                    valid = true;
                }
                break;
        }
        
        if(valid)
        { m_charSLOffset = 16; audio_play_sound(snd_sweep, 1, 0); }
    }
    
    if (m_inputRight)
    {
        var valid = false;
        
        switch(m_charCurrent)
        {
            case 0:
                if(m_currentColor &lt;= 0)
                { m_currentColor = 255; }
                
                m_currentColor -= m_colorAmount;
                valid = true;
                break;
                
            case 1:
                if (m_currentHat &lt; (sprite_get_number(spr_hats) - 1)) 
                { 
                    m_currentHat++; 
                    m_hatXOffset += 16; 
                    valid = true;
                }
                break;
                
            case 2:
                if (m_currentHead &lt; HEAD_AMOUNT-1) 
                { 
                    m_currentHead++; 
                    m_headXOffset += 16;
                    valid = true;
                }
                break;
                
            case 3:
                if (m_currentLeg &lt; LEG_AMOUNT-1) 
                { 
                    m_currentLeg++; 
                    m_legXOffset += 16;
                    valid = true;
                }
                break;
        }
        
        if (valid)
        { m_charSROffset = 16; audio_play_sound(snd_sweep, 1, 0); }
    }
    
    // Lerp thumbs    
    m_hatThumbOffset = lerp(m_hatThumbOffset, (m_charCurrent == 1), 0.2);
    m_headThumbOffset = lerp(m_headThumbOffset, (m_charCurrent == 2), 0.2);
    m_legThumbOffset = lerp(m_legThumbOffset, (m_charCurrent == 3), 0.2);
            
    m_hatXOffset = lerp(m_hatXOffset, 0, 0.35);
    m_headXOffset = lerp(m_headXOffset, 0, 0.35);
    m_legXOffset = lerp(m_legXOffset, 0, 0.35);
    
    
    // Animate the color wheel
    for (i = 0; i &lt; m_colorAmount; i++)
    { 
        var dest;
        
        if((m_currentColor / 17) mod (255 / m_colorAmount) == i)
        { dest = 12; } else { dest = 0; }
        
        m_colDist[i] = lerp(m_colDist[i], dest, 0.4); 
    }
    
    // Set selector cordinates
    if(m_charSelectNormal)
    {
        var lerpVal = 0.33;
        
        // Left up
        m_LUX1 = lerp(m_LUX1, x - 128 - m_charSLOffset, lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos, lerpVal);
        m_LUX2 = lerp(m_LUX2, x - 96 - m_charSLOffset, lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos - 32, lerpVal);
        
        // Left bottom    
        m_LBX1 = lerp(m_LBX1, x - 128 - m_charSLOffset, lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos, lerpVal);
        m_LBX2 = lerp(m_LBX2, x - 96 - m_charSLOffset, lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + 32, lerpVal);
    
        // Right up
        m_RUX1 = lerp(m_RUX1, x + 128 + m_charSROffset, lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos, lerpVal);
        m_RUX2 = lerp(m_RUX2, x + 96 + m_charSROffset, lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos - 32, lerpVal);
        
        // Right bottom      
        m_RBX1 = lerp(m_RBX1, x + 128 + m_charSROffset, lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos, lerpVal);
        m_RBX2 = lerp(m_RBX2, x + 96 + m_charSROffset, lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + 32, lerpVal);
    }
    else // Selector is on ready
    {
        var lerpVal = 0.33;
        var tWidth = string_width(m_readyText) + 16;
        var tHeight = string_height(m_readyText) + 2;
        
        // Up
        m_LUX1 = lerp(m_LUX1, x - (tWidth/2) - 1, lerpVal);
        m_LUY1 = lerp(m_LUY1, m_charSelectPos - (tHeight/2), lerpVal);
        m_LUX2 = lerp(m_LUX2, x + (tWidth/2), lerpVal);
        m_LUY2 = lerp(m_LUY2, m_charSelectPos - (tHeight/2), lerpVal);
        
        // Left    
        m_LBX1 = lerp(m_LBX1, x - (tWidth/2), lerpVal);
        m_LBY1 = lerp(m_LBY1, m_charSelectPos - (tHeight/2), lerpVal);
        m_LBX2 = lerp(m_LBX2, x - (tWidth/2), lerpVal);
        m_LBY2 = lerp(m_LBY2, m_charSelectPos + (tHeight/2), lerpVal);
    
        // Right
        m_RUX2 = lerp(m_RUX2, x + (tWidth/2), lerpVal);
        m_RUY2 = lerp(m_RUY2, m_charSelectPos - (tHeight/2), lerpVal);
        m_RUX1 = lerp(m_RUX1, x + (tWidth/2), lerpVal);
        m_RUY1 = lerp(m_RUY1, m_charSelectPos + (tHeight/2), lerpVal);
        
        // Bottom 
        m_RBX1 = lerp(m_RBX1, x + (tWidth/2), lerpVal);
        m_RBY1 = lerp(m_RBY1, m_charSelectPos + (tHeight/2), lerpVal);
        m_RBX2 = lerp(m_RBX2,  x - (tWidth/2), lerpVal);
        m_RBY2 = lerp(m_RBY2, m_charSelectPos + (tHeight/2), lerpVal);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 1

if(m_currentState == 1)
{
    // Set, depending on the size of the name and if shift is helf, the letters in uppercase or lowercase
    if((string_length(m_name) == 0 &amp;&amp; !m_inputShift) || (m_inputShift &amp;&amp; string_length(m_name) != 0)) 
    { m_alphabet = string_upper(m_alphabet) }
    else { m_alphabet = string_lower(m_alphabet) }
    
    // set the container to the right size
    m_contHeight = 600;    
    if(m_drawHeight &gt; 590)
    {
        m_contWidth = 300; 
    }
    
    // Animate selecor
    m_selectorDist = lerp(m_selectorDist, m_selectorMaxDistance, 0.17);
    m_selectorAngleOff = lerp(m_selectorAngleOff, 0, 0.17);
    
    // Set the name
    m_topText = "Enter your name";
    m_bottomText = "";
    
    // Set all the positions for the letters
    m_letterBoxX[0] = 0;
    m_letterBoxY[0] = 0;  
    
    
    var sx = x - m_drawWidth/2;
    var sy = y - m_drawHeight/6;
    
    var boxIndex = 0;
    
    var bwidth = m_drawWidth / m_xRows;
    var bheight = m_drawHeight / m_yRows;
    
    for (iy = 0; iy &lt; 8; iy++)
    {
        for (ix = 0; ix &lt; 4; ix++)
        {
            if(boxIndex &lt; string_length(m_alphabet))
            {
                m_letterBoxX[boxIndex] = sx + (ix * bwidth); // left x
                m_letterBoxY[boxIndex] = sy + (iy * bheight * 0.66); // upper y
                
                boxIndex++;
            }
        }    
    }
    
    // Animate the letters
    for (i = 0; i &lt; array_length_1d(m_letterBoxX); i++)
    {
        if ((array_length_1d(m_letterRot) - 1) &lt; i)
        { 
            m_letterRot[i] = 0; 
            m_letterSat[i] = 0; 
            m_letterXOff[i] = 0;
            m_letterYOff[i] = 0;
        }
        else
        { 
            m_letterRot[i] = lerp(m_letterRot[i], 0, 0.1); 
            m_letterSat[i] = lerp(m_letterSat[i], 0, 0.2);
            m_letterXOff[i] = lerp(m_letterXOff[i], 0, 0.1);
            m_letterYOff[i] = lerp(m_letterYOff[i], 0, 0.1); 
        }
    }
    
    
    // Get input from the selection
    if(m_inputSelect)
    {
        var newLetter = string_copy(m_alphabet, m_selectorPos+1, 1);
        var nameLength = string_length(m_name);
        m_letterRot[m_selectorPos] = choose(-30, 30);
        m_letterSat[m_selectorPos] = 255;
        m_selectorDist = m_clickDistance;
        
        switch(newLetter)
        {
            case "&lt;":
                // Remove a letter   
                m_name = string_delete(m_name, nameLength, 1);
                audio_play_sound(snd_letterRemove, 1, 0);
                m_selectorAngleOff = -90;
                break;
                
            case "&gt;":
                // Goto next state
                if(nameLength &gt; 0) // name isn't empty
                {
                    m_currentState++;
                    audio_play_sound(snd_charNext, 1, 0);
                    obj_drawRays.m_multiplier += 5;
                }
                break;
                
            default:
                // Add the letter
                if(nameLength &lt; m_maxNameLength)
                { 
                    m_name += newLetter;
                    var snd = audio_play_sound(snd_letterEnter, 1, 0);
                    audio_sound_pitch(snd, random_range(.9, 1.1));
                }
                else
                {
                    // name at limit
                }
                
                if (nameLength == m_maxNameLength) // Move the cursor to confirm if the max length is reached
                {
                    m_selectorPos = array_length_1d(m_letterBoxX)-1;
                    audio_play_sound(snd_letterFull, 1, 0);
                }
                
                m_selectorAngleOff = 90;
                break;
        }
    }
    
    // Move the selection
    var addAmount = 0;
    
    if(m_inputUp &amp;&amp; (m_selectorPos - m_xRows) &gt;= 0)
    {
        m_letterYOff[m_selectorPos] -= 8;
        addAmount -= m_xRows;
    }
    if(m_inputDown &amp;&amp; (m_selectorPos + m_xRows) &lt; array_length_1d(m_letterBoxX))
    {
        m_letterYOff[m_selectorPos] += 8;
        addAmount += m_xRows;
    }
    
    if(m_inputLeft &amp;&amp; ((m_selectorPos-1+m_xRows) mod m_xRows) != m_xRows-1)
    {
        m_letterXOff[m_selectorPos] -= 8;
        addAmount--;
    }
    if(m_inputRight &amp;&amp; ((m_selectorPos+1+m_xRows) mod m_xRows) != 0 &amp;&amp; m_selectorPos+1 &lt; array_length_1d(m_letterBoxX))
    {
        m_letterXOff[m_selectorPos] += 8;
        addAmount++;
    }
    
    if(addAmount != 0) 
    { 
        m_selectorPos += addAmount;
        m_selectorDist =  (m_selectorMaxDistance * .8); 
        audio_play_sound(snd_cursorMove, 1, 0);
    }
    
    // Set the selector's position
    m_selectorX = lerp(m_selectorX, m_letterBoxX[m_selectorPos] + (bwidth / 2), 0.4);
    m_selectorY = lerp(m_selectorY, m_letterBoxY[m_selectorPos] + (bheight / 2), 0.4);
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update for state 0

if(m_currentState == 0)
{
    // set the box to the right size
    m_contHeight = 100;
    m_contWidth = 400;
    
    // Check for input
    if (m_inputSelect) // Go to the next state
    { 
        audio_play_sound(snd_pressedA, 1, 0); 
        m_currentState++; 
        obj_drawRays.m_multiplier += 5;
    } 
    
    m_topText = "";
    m_bottomText = "";
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Create Event"</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initalize variables

enum m_selectStates // The states where the box can be in
{
    PressA, // 0
    EnterName, // 1
    SelectCharacter, // 2
    Ready // 3
}


m_currentState = 0; // The current state of the box
m_ready = false;
//m_totalAmount = noone; // The total amount of this object, used for positioning

m_drawWidth = 0; // The current width of the container
m_drawHeight = 0; // The current height of the container

m_contWidth = 0; // The width where the box lerps to
m_contHeight = 0; // The height where the box lerps to

m_sinCounter = 0; // Value for sinus effects
m_containterSin = (m_id / 4);

m_uwahTimer = 0;

m_topText = "top text";
m_bottomText = "bottom text";

/// Input
m_controllerId = m_id; // Which controller controlls this selector
m_gpDeadzone = 0.3;

m_inputUp = false;
m_inputDown = false;
m_inputLeft = false;
m_inputRight = false;
m_inputSelect = false;
m_inputBack = false;

m_inputTimerMax = 22;
m_inputTimerMin = 10;

for (i = 0; i &lt; 4; i++) // 0 = up, 1 = down, 2 = left, 3 = right
{
    m_inputTimer[i] = 0;
    m_inputTimerCurrent[i] = m_inputTimerMax;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set position

y = room_height / 2;
x = room_width / 4 * (m_controllerId+1) - room_width / 8;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State 1 specifics

var b2b = sqrt(sqr(16) * 2); // Selector's with to exact touch borders

m_selectorMaxDistance = b2b * 1.5;
m_clickDistance = b2b / 1.5;

m_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;&gt;";

m_letterBoxX[0] = 0;
m_letterBoxY[0] = 0;
m_letterRot[0] = 0;
m_letterSat[0] = 0;
m_letterXOff[0] = 0;
m_letterYOff[0] = 0;

m_xRows = 4;
m_yRows = 8;

m_selectorPos = 0;
m_selectorX = x;
m_selectorY = y;
m_selectorDist = 0;
m_selectorAngleOff = 0;

m_name = ""; // The name that the player enters
m_maxNameLength = 10;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State 2 specifics

m_currentHead = 0;
m_currentLeg = 0;
m_currentHat = 0;
m_currentColor = 0;

m_colorAmount = 17;
for (i = 0; i &lt; m_colorAmount; i++)
{ m_colDist[i] = 0; }


m_charCurrent = 0;
m_charSelectPos = y;
m_charSelectNormal = true;

m_headThumbOffset = 0;
m_legThumbOffset = 0;
m_hatThumbOffset = 0;

m_headXOffset = 0;
m_legXOffset = 0;
m_hatXOffset = 0;

m_readyText = "READY"

// Offset from the selectors xpos
m_charSLOffset = 0;
m_charSROffset = 0;

// Coordinates for the selector lines

// Left up
m_LUX1 = x;
m_LUY1 = y;
m_LUX2 = x;
m_LUY2 = y;

// Left bottom
m_LBX1 = x;
m_LBY1 = y;
m_LBX2 = x;
m_LBY2 = y;

// Right up
m_RUX1 = x;
m_RUY1 = y;
m_RUX2 = x;
m_RUY2 = y;

// Right bottom
m_RBX1 = x;
m_RBY1 = y;
m_RBX2 = x;
m_RBY2 = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the container
var w = m_drawWidth/2;
var h = m_drawHeight/2;

// Draw box
draw_set_color(c_black);
draw_set_alpha(0.2);
draw_roundrect(x - w, y - h, x + w, y + h, false);

draw_set_alpha(1);

// Draw outline
draw_roundrect_width(x - w, y - h, x + w, y + h, 6);

// Draw text
draw_set_halign(fa_center)

draw_set_valign(fa_bottom);
draw_text(x, y-h, m_topText);

draw_set_valign(fa_top);
draw_text(x, y+h, m_bottomText);

draw_set_valign(fa_center);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 0
if(m_currentState == 0)
{
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    draw_set_font(fnt_letters);
    
    draw_text(x, y, "Press A to join")
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 1

if(m_currentState == 1)
{
    // Draw the name
    draw_set_color(c_white)
    draw_text_outline(x, y - m_drawHeight/4, m_name, 6, c_black, 360);
    
    // Draw the selector
    for (i=0; i&lt;4; i+=1)
    {
        var angle = i * 90;
        var distance = m_selectorDist + (sin(m_sinCounter) * 5);
        
        var xSelect = m_selectorX + lengthdir_x(distance, angle + 90 + m_selectorAngleOff); //135
        var ySelect = m_selectorY + lengthdir_y(distance, angle + 90 + m_selectorAngleOff); // 135
        
        var xSelect2 = m_selectorX + lengthdir_x(distance * .75, angle + 90 - (45/2) + m_selectorAngleOff); //135
        var ySelect2 = m_selectorY + lengthdir_y(distance * .75, angle + 90 - (45/2) + m_selectorAngleOff); // 135
        
        var xSelect3 = m_selectorX + lengthdir_x(distance * .75, angle + 90 + (45/2) + m_selectorAngleOff); //135
        var ySelect3 = m_selectorY + lengthdir_y(distance * .75, angle + 90 + (45/2) + m_selectorAngleOff); // 135
        
        //draw_sprite_ext(m_selectorPart, -1, xSelect, ySelect, 1, 1, i * 90, c_white, 1);
        
        draw_line(xSelect, ySelect, xSelect2, ySelect2);
        draw_line(xSelect, ySelect, xSelect3, ySelect3);
        
        
    }   
    
    // Draw the letters
    var bwidth = m_drawWidth / m_xRows;
    var bheight = m_drawHeight / m_yRows;
    
    draw_set_color(c_white);
    draw_set_font(fnt_letters);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    
    for (i = 0; i &lt; array_length_1d(m_letterBoxX); i++)
    {
        var xCenter = m_letterBoxX[i] + (bwidth / 2) + m_letterXOff[i];
        var yCenter = m_letterBoxY[i] + (bheight / 2) + m_letterYOff[i];
        
        var letter = string_copy(m_alphabet, i + 1, 1);
        draw_set_color(make_color_hsv(i * 255 / array_length_1d(m_letterBoxX), m_letterSat[i], 255));
        draw_set_halign(fa_center);
        draw_set_valign(fa_center);
        
        draw_text_transformed(xCenter, yCenter, letter,
        1, 1, 0)//m_letterRot[i]);
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 2

if(m_currentState == 2)
{
    var w = m_drawWidth;
    var h = m_drawHeight;
    var offset = 0
    if(m_charSelectNormal) { offset = sin(m_sinCounter) * 10; }
        
    // Draw the selector
    draw_set_color(c_white);
    
    // Left arm
    draw_line(m_LUX1 + offset, m_LUY1, m_LUX2 + offset, m_LUY2);
    draw_line(m_LBX1 + offset, m_LBY1, m_LBX2 + offset, m_LBY2);
    
    // Right arm
    draw_line(m_RUX1 - offset, m_RUY1, m_RUX2 - offset, m_RUY2);
    draw_line(m_RBX1 - offset, m_RBY1, m_RBX2 - offset, m_RBY2);
    
    // Draw the hat
    if(m_currentHat+1 &lt; sprite_get_number(spr_hats))
    { draw_sprite_ext(spr_hats, m_currentHat+1, x + (64 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 1 * m_hatThumbOffset, 1 * m_hatThumbOffset, 0, c_white, 0.5); }
    if(m_currentHat-1 &gt;= 0)
    { draw_sprite_ext(spr_hats, m_currentHat-1, x - (64 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 1 * m_hatThumbOffset, 1 * m_hatThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentHat+2 &lt; sprite_get_number(spr_hats))
    { draw_sprite_ext(spr_hats, m_currentHat+2, x + (96 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 0.5 * m_hatThumbOffset, 0.5 * m_hatThumbOffset, 0, c_white, 0.5); }
    if(m_currentHat-2 &gt;= 0)
    { draw_sprite_ext(spr_hats, m_currentHat-2, x - (96 * m_hatThumbOffset) + m_hatXOffset, y + (h/6), 0.5 * m_hatThumbOffset, 0.5 * m_hatThumbOffset, 0, c_white, 0.5); }
    
    draw_sprite_ext(spr_hats, m_currentHat, x + m_hatXOffset, y + (h/6), 2.5, 2.5, 0, c_white, 1);
    
    
    // Legs
    if(m_currentLeg+1 &lt; LEG_AMOUNT)
    { draw_sprite_ext(leg_sprite(m_currentLeg+1), 0, x - (8) + (64 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12*2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); 
        draw_sprite_ext(leg_sprite(m_currentLeg+1), 0, x + (8) + (64 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12*2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); }
        
    if(m_currentLeg-1 &gt;= 0)
    { draw_sprite_ext(leg_sprite(m_currentLeg-1), 0, x - (8) - (64 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); 
        draw_sprite_ext(leg_sprite(m_currentLeg-1), 0, x + (8) - (64 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 1 * m_legThumbOffset, 1 * m_legThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentLeg+2 &lt; LEG_AMOUNT)
    { draw_sprite_ext(leg_sprite(m_currentLeg+2), 0, x - (8 * 0.5) + (96 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5); 
       draw_sprite_ext(leg_sprite(m_currentLeg+2), 0, x + (8 * 0.5) + (96 * m_legThumbOffset) + m_legXOffset, y + (h / 4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5);}
    
    if(m_currentLeg-2 &gt;= 0)
    { draw_sprite_ext(leg_sprite(m_currentLeg-2), 0, x - (8 * 0.5) - (96 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5); 
       draw_sprite_ext(leg_sprite(m_currentLeg-2), 0, x + (8 * 0.5) - (96 * m_legThumbOffset) + m_legXOffset, y + (h/4) + (12 * 2.5), 0.5 * m_legThumbOffset, 0.5 * m_legThumbOffset, 0, c_white, 0.5);}
    
    draw_sprite_ext(leg_sprite(m_currentLeg), 0, x - (8 * 2.5) + m_legXOffset, y + (h / 4) + (12 * 2.5) , 2.5, 2.5, 0, c_white, 1)
    draw_sprite_ext(leg_sprite(m_currentLeg), 0, x + (8 * 2.5) + m_legXOffset, y + (h / 4) + (12 * 2.5) , 2.5, 2.5, 0, c_white, 1)
    
    // Head
    if(m_currentHead+1 &lt; HEAD_AMOUNT)
    { draw_sprite_ext(head_sprite(m_currentHead+1), 0, x + (64 * m_headThumbOffset) + m_headXOffset, y + (h/4), 1 * m_headThumbOffset, 1 * m_headThumbOffset, 0, c_white, 0.5); }
    if(m_currentHead-1 &gt;= 0)
    { draw_sprite_ext(head_sprite(m_currentHead-1), 0, x - (64 * m_headThumbOffset) + m_headXOffset, y + (h/4), 1 * m_headThumbOffset, 1 * m_headThumbOffset, 0, c_white, 0.5); }
    
    if(m_currentHead+2 &lt; HEAD_AMOUNT)
    { draw_sprite_ext(head_sprite(m_currentHead+2), 0, x + (96 * m_headThumbOffset) + m_headXOffset, y + (h/4), 0.5 * m_headThumbOffset, 0.5 * m_headThumbOffset, 0, c_white, 0.5); }
    if(m_currentHead-2 &gt;= 0)
    { draw_sprite_ext(head_sprite(m_currentHead-2), 0, x - (96 * m_headThumbOffset) + m_headXOffset, y + (h/4), 0.5 * m_headThumbOffset, 0.5 * m_headThumbOffset, 0, c_white, 0.5); }
      
    draw_sprite_ext(head_sprite(m_currentHead), 0, x + m_headXOffset, y + (h/4), 2.5, 2.5, 0, c_white, 1);
    
    // Color block
    draw_set_color(make_color_hsv(m_currentColor, 255, 255));
                    
    // Color circle
    for (i = 0; i &lt; (255 / m_colorAmount); i++)
    {
        var colorAmount = (255 / m_colorAmount);
        var angleOff = 0;
        
        var sizeTop = 64 + m_colDist[i];
        var sizeBottom = 32 + m_colDist[i];
        
        var x1 = x + lengthdir_x(sizeTop, i * (360 / colorAmount) + angleOff);
        var y1 = y - (h/4) + lengthdir_y(sizeTop, i * (360 / colorAmount) + angleOff);
        
        var x2 = x + lengthdir_x(sizeTop, (i+1) * (360 / colorAmount) + angleOff);
        var y2 = y - (h/4) + lengthdir_y(sizeTop, (i+1) * (360 / colorAmount) + angleOff);
        
        var x3 = x + lengthdir_x(sizeBottom, i * (360 / colorAmount) + angleOff);
        var y3 = y - (h/4) + lengthdir_y(sizeBottom, i * (360 / colorAmount) + angleOff);
        
        var x4 = x + lengthdir_x(sizeBottom, (i+1) * (360 / colorAmount) + angleOff);
        var y4 = y - (h/4) + lengthdir_y(sizeBottom, (i+1) * (360 / colorAmount) + angleOff);
        
        draw_set_color(make_color_hsv(i * m_colorAmount, 255, 255));        
        draw_paralellogram(x1, y1, x2, y2, x3, y3, x4, y4, false);
        
        draw_set_color(c_black);
        draw_paralellogram(x1, y1, x2, y2, x3, y3, x4, y4, true);
        
    }
                     
    // Draw ready
    draw_set_color(make_color_hsv(m_currentColor, 255, 255));
    draw_text_outline(x, y + (h/2.5), m_readyText, 1, c_black, 20);
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw exclusively for state 3

if(m_currentState == 3)
{                 
    draw_set_color(c_white);
    
    
    draw_text_transformed(x, y, "READY!", 
        1 + (cos(m_containterSin * 2) * 0.2), 1 + (sin(m_containterSin * 3) * 0.2), 
        sin(m_sinCounter) * 20)
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw outline
var w = m_drawWidth/2;
var h = m_drawHeight/2;


draw_set_color(c_black);
draw_set_alpha(1);

draw_roundrect_width(x - w, y - h, x + w, y + h, 6);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
